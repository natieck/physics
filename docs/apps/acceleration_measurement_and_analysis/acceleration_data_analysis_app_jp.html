<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Acceleration Data Analysis App</title>
    <script src="math.min.js" charset="utf-8"></script>
    <script src="pca.min.js" charset="utf-8"></script>
    <script src="plotly-2.35.2.min.js" charset="utf-8"></script>
    <script src="general_least-squares_smoothing.js" charset="utf-8"></script>
  </head>
<body>

<style type="text/css">
	.tborder {border: 1px #000000 solid; border-collapse: collapse; margin: auto; font-size: small;}
	.tborder th {border: 1px #000000 solid; border-collapse: collapse; text-align: center; background-color:#66aaff; padding: 0 10px}
	.tborder td {border: 1px #000000 solid; border-collapse: collapse; text-align: right; padding: 0 10px}
  .plotly_graph {
    border: 1px #888888 solid;
    resize: both;
    overflow: hidden;
    position: static;
  }
  .whsize {
    width: 64px;
    height: 16px;
    line-height:80%;
    position: absolute;
  }
  @keyframes fadeOut {
    0% {opacity: 1;}
    100% {opacity: 0;}
  }
  .fade-out {
    animation: fadeOut 3s forwards;
  }
</style>

<a name="pagetop"></a>

<h2>加速度データ解析アプリ</h2>

<span style="font-weight:bold;">&#9679; 加速度データのCSVファイルのアップロード</span>
<div style="margin-left:1em;">
<input type="file" id="file_input" accept="text/csv" />
&nbsp;&nbsp;
<label><input type="checkbox" id="check_label" checked />先頭行をラベルとする．</label>
</div>

<br />

<details open id="data_details" style="margin-left:1em;display:none;">
  <summary>読込データ</summary>
  <span id="sensor_data_download"></span>
  <div style="overflow:auto;white-space:nowrap;height:300px;">
    <table id="data_table" class="tborder"></table>
  </div>
  <p style="margin-left:1em;">＜単位の設定＞&nbsp;&nbsp;長さの単位：
    <select id="length_unit" onchange="unit_change()">
      <option value="km">kilometer</option>
      <option value="m" selected>meter</option>
      <option value="cm">centimeter</option>
      <option value="mm">millimeter</option>
    </select>
    &nbsp;&nbsp;時間の単位：
    <select id="time_unit" onchange="unit_change()">
      <option value="h">hour</option>
      <option value="min">minute</option>
      <option value="s" selected>second</option>
      <option value="ms">millisecond</option>
    </select>
  </p>
</details>

<br />

<div id="time_acc_items" style="display:none;">
  <details>
    <summary><span style="font-weight:bold;">グラフのマーカー・線の設定</span></summary>
    &nbsp;&nbsp;モード：
    <select id="plot_mode" onchange="plot_mode_change()">
      <option value="markers">マーカー</option>
      <option value="lines" selected>線</option>
      <option value="lines+markers">マーカー＋線</option>
    </select>
    &nbsp;&nbsp;&nbsp;&nbsp;サイズ・幅：小&nbsp;<input type="range" value="2" min="0" max="8" id="plot_size" onchange="plot_size_change()" />&nbsp;大
  </details>
  <br />
  <span style="font-weight:bold;">&#9679; 時刻列と加速度列の選択</span>
  <div style="margin-left:1em;">
    時刻列：&nbsp;<select id="time_select"></select>&nbsp;&nbsp;<span style="color:red;font-size:smaller">※ 時刻列を変更したら加速度列を選択しなおしてください．</span>
    <br />
    &#x21E9; 加速度列（複数選択可，最大3つ）<span id="message_acc_select" style="color:red;font-size:smaller"></span><br />
    <select id="acc_select" multiple></select>&nbsp;&nbsp;<button onclick="select_time_acc();">決定</button>&nbsp;&nbsp;
    <span id="message_time_acc_items"></span>
  </div>
  <br />
</div>

<div id="time_range" style="display:none;">
  <div id="data_graph" class="plotly_graph"><div class="whsize"></div></div>
  <br />
  <span style="font-weight:bold;">&#9679; 分析に使用する時間領域の設定</span>
  <div style="margin-left:1em;">
    開始時刻<select id="start_time_select"></select>&nbsp;&nbsp;
    終了時刻<select id="end_time_select"></select>&nbsp;&nbsp;
    <button onclick="select_time_range();">決定</button>&nbsp;&nbsp;
    <span id="message_time_range"></span>
  </div>
  <br />
</div>

<details id="acc_details" style="margin-left:1em;display:none;">
  <summary>加速度データ</summary>
  &nbsp;&nbsp;&nbsp;&nbsp;<button onclick="download_acc_data();">ダウンロード</button>&nbsp;&nbsp;
  <span style="color:red;font-size:smaller">※ CSVファイルとしてダウンロードします．</span>
  <div id="acc_area" style="overflow:auto;white-space:nowrap;height:300px;">
    <table id="acc_table" class="tborder"></table>
  </div>
</details>

<div id="acc_graph" style="margin-left:1em;display:none;">
  <div id="acc_graph0" style="float:left;display:none;" class="plotly_graph"><div class="whsize"></div></div>
  <div id="acc_graph1" style="float:left;display:none;" class="plotly_graph"><div class="whsize"></div></div>
  <div id="acc_graph2" style="float:left;display:none;" class="plotly_graph"><div class="whsize"></div></div>
</div>

<br style="clear:both;"/><br />

<div id="acc_smoothing" style="display:none;">
  <details id="acc_zero_adjust">
    <summary><span style="font-weight:bold;">加速度のゼロ調整</span></summary>
    <div id="acc_zero_adjust_area" style="margin-left:1em;"></div>
  </details>
  <br />

  <span style="font-weight:bold;">&#9679; 加速度データの平滑化</span>

  <details id="acc_fourier_transformation" style="margin-left:1em;">
    <summary><span style="font-weight:bold;">フーリエ変換による平滑化</span></summary>
    <div style="margin-left:1em;">
      <button onclick="acc_fft();">フーリエ変換</button>
      <label><input type="checkbox" id="check_acc_fft_flag" checked />時間刻み幅が一定でない</label>
      （時間分割数：<input id="acc_fft_div" type="range" /><span id="acc_fft_ndiv_value"></span>）
      <div id="acc_fft_graph" style="display:none;" class="plotly_graph"><div class="whsize"></div></div>
    </div>
    <div id="acc_inverse_fourier_transformation" style="margin-left:1em;display:none;">
      <button onclick="acc_ifft_smoothing();">逆フーリエ変換による平滑化</button>&nbsp;
      カットオフ周波数：<input id="acc_ifft_cut_freq" type="range" /><span id="acc_ifft_cut_freq_value"></span>
    </div>
    <br />
  </details>

  <details id="acc_least_square_smoothing" style="margin-left:1em;">
    <summary><span style="font-weight:bold;">最小二乗近似による平滑化</span></summary>
    <div style="margin-left:1em;">
      平滑化フィルタの幅：<input id="acc_filter_width" type="range" />&nbsp;&nbsp;<input type="number" id="acc_filter_width_value" step="0.1" />
      &nbsp;&nbsp;<span id="message_acc_least_square_smoothing"></span><br />
      近似する多項式の次数：<input type="number" id="acc_polynomial_order" value="3" min="0" max="10" /><br />
      <label><input type="checkbox" id="check_acc_flag" checked />フィルタ幅のとれないデータの最初の方と最後の方は幅を自動調整する</label><br />
      <button onclick="acc_least_square_smoothing();">最小二乗近似による平滑化</button>
    </div>
    <br />
  </details>

  <div id="acc_for_integral_items" style="margin-left:1em;display:none;">
    <br />
    <span style="font-weight:bold;">数値積分する加速度データの選択</span>
    &nbsp;&nbsp;<button onclick="clear_acc_smoothing();">平滑化のクリア</button>
    <br />
    <form id="acc_for_integral_radio_select">
      <label><input type="radio" name="acc_radio" value="0" checked />元のデータ</label>
      <label><input type="radio" name="acc_radio" value="1" />平滑化(smth)データ</label>
      <label><input type="radio" name="acc_radio" value="2" />差分(diff)データ</label>
    </form>
  </div>

</div>

<br />

<div id="set_initial_velocity" style="display:none;"></div>

<br />

<details id="vel_details" style="margin-left:1em;display:none;">
  <summary>速度データ</summary>
  &nbsp;&nbsp;&nbsp;&nbsp;<button onclick="download_vel_data();">ダウンロード</button>&nbsp;&nbsp;
  <span style="color:red;font-size:smaller">※ CSVファイルとしてダウンロードします．</span>
  <div id="vel_area" style="overflow:auto;white-space:nowrap;height:300px;">
    <table id="vel_table" class="tborder"></table>
  </div>
</details>

<div id="vel_graph" style="margin-left:1em;display:none;">
  <div id="vel_graph0" style="float:left;display:none;" class="plotly_graph"><div class="whsize"></div></div>
  <div id="vel_graph1" style="float:left;display:none;" class="plotly_graph"><div class="whsize"></div></div>
  <div id="vel_graph2" style="float:left;display:none;" class="plotly_graph"><div class="whsize"></div></div>
</div>

<br style="clear:both;"/><br />

<div id="vel_smoothing" style="display:none;">
  <details id="vel_zero_adjust">
    <summary><span style="font-weight:bold;">速度のゼロ調整</span></summary>
    <div id="vel_zero_adjust_area" style="margin-left:1em;"></div>
  </details>
  <br />

  <span style="font-weight:bold;">&#9679; 速度データの平滑化</span>

  <details id="vel_fourier_transformation" style="margin-left:1em;">
    <summary><span style="font-weight:bold;">フーリエ変換による平滑化</span></summary>
    <div style="margin-left:1em;">
      <button onclick="vel_fft();">フーリエ変換</button>
      <label><input type="checkbox" id="check_vel_fft_flag" checked />時間刻み幅が一定でない</label>
     （時間分割数：<input id="vel_fft_div" type="range" /><span id="vel_fft_ndiv_value"></span>）
      <div id="vel_fft_graph" style="display:none;" class="plotly_graph"><div class="whsize"></div></div>
    </div>
    <div id="vel_inverse_fourier_transformation" style="margin-left:1em;display:none;">
      <button onclick="vel_ifft_smoothing();">逆フーリエ変換による平滑化</button>&nbsp;
      カットオフ周波数：<input id="vel_ifft_cut_freq" type="range" /><span id="vel_ifft_cut_freq_value"></span>
    </div>
    <br />
  </details>

  <details id="vel_least_square_smoothing" style="margin-left:1em;">
    <summary><span style="font-weight:bold;">最小二乗近似による平滑化</span></summary>
    <div style="margin-left:1em;">
      平滑化フィルタの幅：<input id="vel_filter_width" type="range" />&nbsp;&nbsp;<input type="number" id="vel_filter_width_value" step="0.1" />
      &nbsp;&nbsp;<span id="message_vel_least_square_smoothing"></span><br />
      近似する多項式の次数：<input type="number" id="vel_polynomial_order" min="0" max="10" /><br />
      <label><input type="checkbox" id="check_vel_flag" />フィルタ幅のとれないデータの最初の方と最後の方は幅を自動調整する</label><br />
      <button onclick="vel_least_square_smoothing();">最小二乗近似による平滑化</button>
    </div>
    <br />
  </details>

  <div id="vel_for_integral_items" style="margin-left:1em;display:none;">
    <br />
    <span style="font-weight:bold;">数値積分する速度データの選択</span>
    &nbsp;&nbsp;<button onclick="clear_vel_smoothing();">平滑化のクリア</button>
    <br />
    <form id="vel_for_integral_radio_select">
      <label><input type="radio" name="vel_radio" value="0" checked />元のデータ</label>
      <label><input type="radio" name="vel_radio" value="1" />平滑化(smth)データ</label>
      <label><input type="radio" name="vel_radio" value="2" />差分(diff)データ</label>
    </form>
  </div>

</div>

<br />

<div id="set_initial_position" style="display:none;"></div>

<br />

<details id="pos_details" style="margin-left:1em;display:none;">
  <summary>位置データ</summary>
  &nbsp;&nbsp;&nbsp;&nbsp;<button onclick="download_pos_data();">ダウンロード</button>&nbsp;&nbsp;
  <span style="color:red;font-size:smaller">※ CSVファイルとしてダウンロードします．</span>
  <div id="pos_area" style="overflow:auto;white-space:nowrap;height:300px;">
    <table id="pos_table" class="tborder"></table>
  </div>
</details>

<div id="pos_graph" style="margin-left:1em;display:none;">
  <div id="pos_graph0" style="float:left;display:none;" class="plotly_graph"><div class="whsize"></div></div>
  <div id="pos_graph1" style="float:left;display:none;" class="plotly_graph"><div class="whsize"></div></div>
  <div id="pos_graph2" style="float:left;display:none;" class="plotly_graph"><div class="whsize"></div></div>
</div>

<br style="clear:both;"/><br />

<div id="pos_smoothing" style="display:none;">
  <details id="pos_zero_adjust">
    <summary><span style="font-weight:bold;">位置のゼロ調整</span></summary>
    <div id="pos_zero_adjust_area" style="margin-left:1em;"></div>
  </details>
  <br />

  <span style="font-weight:bold;">&#9679; 位置データの平滑化</span>

  <details id="pos_fourier_transformation" style="margin-left:1em;">
    <summary><span style="font-weight:bold;">フーリエ変換による平滑化</span></summary>
    <div style="margin-left:1em;">
      <button onclick="pos_fft();">フーリエ変換</button>
      <label><input type="checkbox" id="check_pos_fft_flag" checked />時間刻み幅が一定でない</label>
      （時間分割数：<input id="pos_fft_div" type="range" /><span id="pos_fft_ndiv_value"></span>）
      <div id="pos_fft_graph" style="display:none;" class="plotly_graph"><div class="whsize"></div></div>
    </div>
    <div id="pos_inverse_fourier_transformation" style="margin-left:1em;display:none;">
      <button onclick="pos_ifft_smoothing();">逆フーリエ変換による平滑化</button>&nbsp;
      カットオフ周波数：<input id="pos_ifft_cut_freq" type="range" /><span id="pos_ifft_cut_freq_value"></span>
    </div>
    <br />
  </details>

  <details id="pos_least_square_smoothing" style="margin-left:1em;">
    <summary><span style="font-weight:bold;">最小二乗近似による平滑化</span></summary>
    <div style="margin-left:1em;">
      平滑化フィルタの幅：<input id="pos_filter_width" type="range" />&nbsp;&nbsp;<input type="number" id="pos_filter_width_value" step="0.1" />
      &nbsp;&nbsp;<span id="message_pos_least_square_smoothing"></span><br />
      近似する多項式の次数：<input type="number" id="pos_polynomial_order" /><br />
      <label><input type="checkbox" id="check_pos_flag" />フィルタ幅のとれないデータの最初の方と最後の方は幅を自動調整する</label><br />
      <button onclick="pos_least_square_smoothing();">最小二乗近似による平滑化</button>
    </div>
    <br />
  </details>

  <div id="pos_for_output_items" style="margin-left:1em;display:none;">
    <br />
    <span style="font-weight:bold;">出力する位置データの選択</span>
    &nbsp;&nbsp;<button onclick="clear_pos_smoothing();">平滑化のクリア</button>
    <br />
    <form id="pos_for_output_radio_select">
      <label><input type="radio" name="pos_radio" value="0" checked />元のデータ</label>
      <label><input type="radio" name="pos_radio" value="1" />平滑化(smth)データ</label>
      <label><input type="radio" name="pos_radio" value="2" />差分(diff)データ</label>
    </form>
  </div>

</div>

<br />

<div id="acc_vel_pos_output" style="display:none;">
  <span style="font-weight:bold;">&#9679; 加速度・速度・位置のデータ出力</span>
  &nbsp;&nbsp;<button onclick="merge_acc_vel_pos_data();">出力</button><span id="data_download"></span><br /><br />
  <div id="acc_vel_pos_area" style="margin-left:1em;overflow:auto;white-space:nowrap;display:none;">
    <table id="acc_vel_pos_table" class="tborder"></table>
  </div>
  <br />
  <div id="acc_vel_pos_graph" style="margin-left:1em;display:none;">
    <div id="tacc_graph" style="float:left;" class="plotly_graph"><div class="whsize"></div></div>
    <div id="tvel_graph" style="float:left;" class="plotly_graph"><div class="whsize"></div></div>
    <div id="tpos_graph" style="float:left;" class="plotly_graph"><div class="whsize"></div></div>
  </div>
</div>

<br style="clear:both;" /><br />

<div id="trajectory" style="display:none;">
  <span style="font-weight:bold;">&#9679; 軌跡のプロット</span><br />
  <div style="margin-left:1em;">
    <span style="font-weight:bold;">時間領域の選択</span><br />
    <div style="margin-left:1em;">
      開始時刻<select id="trjc_start_time_select"></select>&nbsp;&nbsp;
      終了時刻<select id="trjc_end_time_select"></select>&nbsp;&nbsp;
      <button onclick="plot_trajectory();">決定</button>
      &nbsp;&nbsp;<span id="message_trjc_time_range"></span>
    </div>
    <div id="trajectory_plot" style="display:none;" class="plotly_graph"><div class="whsize"></div></div>
    <span id="message_trajectory"></span>
  </div>
</div>

<br />

<details id="axis_conversion_with_pca" style="display:none;">
  <summary><span style="font-weight:bold;">主成分分析による座標軸の変換</span></summary>
  <div style="margin-left:1em;">
    <span style="font-weight:bold;">主成分分析を行うデータ列を選択してください（2つ以上3つ以下）．</span>
    <div style="margin-left:1em;">
      <form id="pca_data_radio_select">
        <label><input type="radio" name="motion_data" value="acc" checked />加速度</label>
        <label><input type="radio" name="motion_data" value="vel" />速度</label>
        <label><input type="radio" name="motion_data" value="pos" />位置</label>
      </form>
      <select id="pca_data_select" multiple></select>
      <span id="message_pca_data_select"></span><br />
    </div>
    <span style="font-weight:bold;">時間領域の選択</span><br />
    <div style="margin-left:1em;">
      開始時刻<select id="pca_start_time_select"></select>&nbsp;&nbsp;
      終了時刻<select id="pca_end_time_select"></select>&nbsp;&nbsp;
      <button onclick="calc_pca();">決定</button>
      &nbsp;&nbsp;<span id="message_pca_time_range"></span>
    </div>
  </div>
</div>

<div id="pca_result" style="margin-left:1em;display:none;">
  <div id="pca_coeff"></div>
  <div id="pca_graph" class="plotly_graph"><div class="whsize"></div></div>
  <button onclick="all_axis_conversion();">出力データの座標軸の変換</button>
</div>

</div>

</details>

<hr />
<p style="text-align:center;"><a href="#pagetop">ページトップ</a></p>

<script>
  let data;  // 読込データ
  let nrow,ncol;  // 読込データの行数と列数
  let time_index;  // 時刻列の番号
  let nacc=0,nuacc=0,nuvel=0,nupos=0,npca=0;  // 加速度データの個数，平滑処理時の加速度・速度・位置データの個数，主成分分析データの個数 
  let acc_rv,vel_rv,pos_rv;  // 平滑化時の加速度・速度・位置データについて選択したラジオボタンの値
  let acc_index=[],iacc_index=[],ivel_index=[],pca_index=[];  // 加速度データ・積分する加速度データ・積分する速度データ・主成分分析データの選択オプションの番号
  let time0_data,acc0_data=[];  // 時刻データ，加速度データ
  let time_data=[];  // 時間範囲指定した時刻データ
  let acc_data=[],unif_acc_data=[];  // 時間範囲指定した加速度データ，平滑化したデータ・差分データを統合した加速度データ
  let vel_data=[],unif_vel_data=[];  // 速度データ，平滑化したデータ・差分データを統合した速度データ
  let pos_data=[],unif_pos_data=[];  // 位置データ，平滑化したデータ・差分データを統合した位置データ
  let acc_vel_pos_data=[];  // 加速度・速度・位置を統合したデータ
  let trjc_data=[],trjc_vel=[],trjc_acc=[];  // 軌跡データ，軌跡表示用の速度・加速度データ
  let acc_fft_data=[],vel_fft_data=[],pos_fft_data=[];  // 加速度のフーリエ変換データ，速度のフーリエ変換データ，位置のフーリエ変換データ
  let ntwidth;  // 時間範囲指定した時刻のデータ数
  let pcares;  // 主成分分析の結果（固有値・固有値ベクトル）
  let step=0,dstep=1;  // 軌跡のプロットのステップ数
  let vec_len=10;  // 軌跡プロットにおける速度・加速度ベクトルの基準長
  let stopflag=0;  // 軌跡のアニメーションの停止フラグ
  let width1,width2,height1,height2;  // プロットの幅・高さ
  let trjc_start_time_index,aid;  // 軌跡の開始時刻インデックス，アニメーションID
  let time_unit,acc_unit,vel_unit,pos_unit;  // 時刻・加速度・速度・位置の単位テキスト
  let plot_mode='lines';  // プロットのマーカー・線のモード
  let marker_size,line_width;  // マーカーサイズ，線幅
  const zero_adjust_val={acc:[0,0,0],vel:[0,0,0],pos:[0,0,0]};  // ゼロ調整の値
  const dev_type=device_judgement();  // デバイスの種類
  const trjc_elem=document.getElementById('trajectory_plot');  // 軌跡表示用のdiv要素
  let tpdata,pdata;  // 軌跡表示データ
  let vel_arw,acc_arw,vel_cone,acc_cone;  // 速度・加速度ベクトル表示用
  const conescale=0.05;  // 3次元軌跡における速度・加速度ベクトルの矢印のスケール

  // 実行デバイスの検出
  function device_judgement(){
    if(window.matchMedia){
        if(window.matchMedia('(max-device-width: 768px)').matches){
            return 'phone';
        }else if(window.matchMedia("(any-hover:hover)").matches){
            return 'pc';
        }else{
            return 'tablet';
        }
    }else{
        return 'unknown';
    }
  }

  // 加速度選択オプションにおいて，スマートフォンとPCでメッセージを変える．
  if(dev_type==='phone'){
    let bw=document.documentElement.clientWidth;
    width1=width2=bw;
    height1=height2=math.round(0.75*bw);
    document.getElementById('message_acc_select').innerHTML='※ 選択した後に必ず決定ボタンを押してください．'
  }else{
    width1=600;height1=math.round(0.75*width1);
    width2=480;height2=math.round(0.75*width2);
    document.getElementById('message_acc_select').innerHTML='※ ShiftキーまたはCtrlキーを押しながら項目をクリックすると複数選択できます．'
  }

  unit_change();       // 単位の設定
  plot_mode_change();  // プロットのマーカー・線のモード設定
  plot_size_change();  // プロットのマーカー・線のサイズ設定

  // Web storage (sessionStorage)にセンサーアプリで取得した加速度CSVデータがあれば読み込む
  const data_str=sessionStorage.getItem('acceleration_data');
  sessionStorage.removeItem('acceleration_data');
  if(data_str!=null){
    processData(data_str);
    let insertElement='&nbsp;&nbsp;&nbsp;&nbsp;<button onclick="download_sensor_data();">ダウンロード</button>';
    insertElement+='&nbsp;&nbsp;<span style="color:red;font-size:smaller">※ CSVファイルとしてダウンロードします．</span>';
    document.getElementById('sensor_data_download').innerHTML=insertElement;
  }

  // ファイルが選択されたら、読み込む
  document.getElementById('file_input').addEventListener('change',function(event){
    const file=event.target.files[0];
    readFile(file);
    document.getElementById('sensor_data_download').innerHTML='';
  });

  // グラフをプロットするdiv領域のサイズ変更があった場合，領域サイズに応じてプロットサイズを変更する．
  const elems = document.querySelectorAll('.plotly_graph');
  elems.forEach(elem => {
    new ResizeObserver((entries) => {
      if(entries[0].target.classList.contains('js-plotly-plot')){
        const x = entries[0].target.getBoundingClientRect().left + window.pageXOffset;
        const y = entries[0].target.getBoundingClientRect().top + window.pageYOffset;
        const w = entries[0].contentBoxSize ? entries[0].contentBoxSize[0].inlineSize : entries[0].contentRect.width;
        const h = entries[0].contentBoxSize ? entries[0].contentBoxSize[0].blockSize : entries[0].contentRect.height;
        Plotly.relayout(entries[0].target,{autosize: true});
        const d = entries[0].target.querySelector('.whsize');
        d.innerHTML = `<span style="font-size:x-small;color:#ff8888;" class="fade-out">${w} x ${h}</span>`;
        d.style.left = `${x+w-70}px`;
        d.style.top = `${y+h-20}px`;
      }
    }).observe(elem);
  });

  // FileReader APIを使ってファイルを読み込む関数
  function readFile(file){
      const reader=new FileReader();

      // 読み込みが完了したらCSVデータを処理
      reader.onload=function(event){
          const csvData=event.target.result;
          processData(csvData);
      };

      // ファイルをテキストとして読み込む
      reader.readAsText(file);
  }

  // CSVデータを処理する関数
  function processData(csvData){
    let i;

    // CSVデータを行に分割
    const rows=csvData.split('\n');

    // 各行をカンマで分割し2次元配列dataに格納
    data=rows.map(row => row.split(','));

    // 2次元配列dataの1行目のデータ数より最終行目のデータ数が少なければ最終行を削除
    nrow=data.length;
    ncol=data[0].length;
    if(data[nrow-1].length<ncol){
      data.pop();
      nrow--;
    }

    // 格納したデータの各行の改行コードに \r があれば削除
    for(i=0;i<nrow;i++)data[i][ncol-1]=data[i][ncol-1].replace(/\r/g,'');

    // データの先頭行がラベルでなければ item# というラベルを付与
    if(document.getElementById('check_label').checked==false){
      let label=[];
      for(i=1;i<=ncol;i++)label.push('item'+String(i));
      data.splice(0,0,label);
    }

    clear_area(0);  // 表示のクリア

    // 時刻列と加速度列の選択時のオプション生成
    let insertElement1='';
    let insertElement2='';
    let insertElement3='';
    time_index=0;
    data.forEach((element,index) => {
      if(index==0){
        insertElement1='<tr style="position:sticky;top:0px;"><th>No.</th>';
        element.forEach((childElement,num) => {
          insertElement1+=`<th>${childElement}</th>`;
          if(num!=parseInt(time_index)){
            insertElement2+=`<option value="${num}">${childElement}</option>`;
            insertElement3+=`<option value="${num}">${childElement}</option>`;
          }
          else insertElement2=`<option value="${num}" selected>${childElement}</option>`;
        });
        insertElement1+='</tr>';
      }else{
        insertElement1+=`<tr><td>${index}</td>`;
        element.forEach((childElement) => {
          insertElement1+=`<td>${childElement}</td>`;
        });
        insertElement1+='</tr>';
     }
    });
    document.getElementById('data_table').innerHTML=insertElement1;
    document.getElementById('time_select').innerHTML=insertElement2;
    document.getElementById('time_select').addEventListener('change',time_select_change);
    document.getElementById('acc_select').innerHTML=insertElement3;
    document.getElementById('data_details').style.display='block';
    document.getElementById('time_acc_items').style.display='block';
  }

  // 単位の変更
  function unit_change(){
    let length_unit=document.getElementById('length_unit').value;
    time_unit=document.getElementById('time_unit').value;
    pos_unit='['+length_unit+']';
    vel_unit='['+length_unit+'/'+time_unit+']';
    acc_unit='['+length_unit+'/'+time_unit+'<sup>2</sup>'+']';
  }

  // プロットのマーカー・線のモード変更
  function plot_mode_change(){
    plot_mode=document.getElementById('plot_mode').value;
  }

  // プロットのマーカー・線のサイズ変更
  function plot_size_change(){
    const val=Number(document.getElementById('plot_size').value);
    marker_size=val+1;
    line_width=math.floor(val/3)+1;
  }

  // 時刻列の変更処理
  function time_select_change(){
    time_index=document.getElementById('time_select').value;
    let insertElement='';
    data[0].forEach((element,index) => {
      if(index!=parseInt(time_index)){
        insertElement+=`<option value="${index}">${element}</option>`;
      }
    });
    document.getElementById('acc_select').innerHTML=insertElement;
  }

  // 時刻列と加速度列の選択時の処理
  function select_time_acc(){
    let i,j;

    clear_area(1);

    nacc=0;
    acc_index.length=0;
    acc_data.length=0;
    for(let option of document.getElementById('acc_select').options){
      if(option.selected){
        acc_index.push(option.value);
        nacc++;
      }
    }

    if(nacc<1||nacc>3){
      document.getElementById('time_range').style.display='none';
      document.getElementById('message_time_acc_items').innerHTML='加速度はいずれか1つ以上3つ以下で選択してください！';
      return;
    }
    document.getElementById('message_time_acc_items').innerHTML='';

    time0_data=data.map(item => item[time_index]);
    for(i=0;i<nacc;i++)acc0_data[i]=data.map(item => item[acc_index[i]]);

    if(!document.getElementById('data_graph').classList.contains('js-plotly-plot')){
      document.getElementById('data_graph').style.width=`${width1}px`;
      document.getElementById('data_graph').style.height=`${height1}px`;
    }
    plot_graph(time0_data,acc0_data,0,nacc-1,'選択した加速度データのグラフ','加速度'+acc_unit,'data_graph');

    let insertElement='';
    time0_data.forEach((element,index) => {
      if(index>0){
        insertElement+=`<option value="${index}">${element}</option>`;
      }
    });
    document.getElementById('start_time_select').innerHTML=insertElement;
    document.getElementById('end_time_select').innerHTML=insertElement;
    document.getElementById('end_time_select').options[nrow-2].selected=true;
    document.getElementById('time_range').style.display='block';
  }

  // 時間範囲選択時の処理
  function select_time_range(){
    let i,j;
    let w;

    clear_area(2);

    const start_time_index=Number(document.getElementById('start_time_select').value);
    const end_time_index=Number(document.getElementById('end_time_select').value);
    ntwidth=end_time_index-start_time_index+1;
    let ts=time0_data[start_time_index];
    let te=time0_data[end_time_index];
    if(te-ts<0){
      document.getElementById('message_time_range').innerHTML='終了時刻は開始時刻より後に設定してください！';
      return;
    }
    document.getElementById('message_time_range').innerHTML='';

    time_data=time0_data.slice(start_time_index,end_time_index+1);
    time_data.splice(0,0,time0_data[0]);
    for(j=1;j<=ntwidth;j++)time_data[j]=Number(time_data[j]);
    for(i=0;i<nacc;i++){
      acc_data[i]=acc0_data[i].slice(start_time_index,end_time_index+1);
      acc_data[i].splice(0,0,acc0_data[i][0]);
      for(j=1;j<=ntwidth;j++)acc_data[i][j]=Number(acc_data[i][j]);
    }
    nuacc=nacc;
    unif_acc_data=copyMatrix(acc_data);

    let insertElement=make_table(time_data,acc_data,nacc);
    document.getElementById('acc_table').innerHTML=insertElement;
    document.getElementById('acc_details').style.display='block';

    plot_graph_all('acc',width2,height2);
    document.getElementById('acc_graph').style.display='block';
  
    set_fft_zero_adjust(acc_data,nacc,'acc');

    const acc_fileter_width=document.getElementById('acc_filter_width');
    acc_filter_width.min=(te-ts)/ntwidth;
    acc_filter_width.max=te-ts;
    acc_filter_width.step='any';
    acc_filter_width.value=0.5*(te-ts)*(ntwidth+1)/ntwidth;
    acc_filter_width.addEventListener('input',function(){filter_width_change('acc');});
    filter_width_change('acc');
    document.getElementById('acc_smoothing').style.display='block';
    document.getElementsByName('acc_radio')[0].checked=true;
    document.getElementById('acc_for_integral_items').style.display='none';

    insertElement=`<span style="font-weight:bold;">&#9679; 初期速度（開始時刻 t = ${time_data[1]} s での速度）の設定</span><br />`;
    insertElement+='<div style="margin-left:1em;">';
    for(i=0;i<nacc;i++)insertElement+=`第${i+1}成分：<input type="number" id="inivel${i+1}" value="0.0" step="0.1" /><br />`;
    insertElement+='<button onclick="calc_velocity();">速度の計算（数値積分）</button>';
    insertElement+='</div>';
    document.getElementById('set_initial_velocity').innerHTML=insertElement;
    document.getElementById('set_initial_velocity').style.display='block';

    const pca_chckbtn=document.getElementById('pca_data_radio_select');
    pca_chckbtn.addEventListener('change',function(){pca_check_button_change(pca_chckbtn.motion_data.value);});
    insertElement='';
    for(i=0;i<nuacc;i++)insertElement+=`<option value="${i}">${unif_acc_data[i][0]}</option>`;
    document.getElementById('pca_data_select').innerHTML=insertElement;

    insertElement='';
    time_data.forEach((element,index) => {
      if(index>0){
        insertElement+=`<option value="${index}">${element}</option>`;
      }
    });
    document.getElementById('pca_start_time_select').innerHTML=insertElement;
    document.getElementById('pca_end_time_select').innerHTML=insertElement;
    document.getElementById('pca_end_time_select').options[ntwidth-2].selected=true;
    if(nacc>1)document.getElementById('axis_conversion_with_pca').style.display='block';
  }

  // ゼロ調整に用いるデータの平均の計算
  function calc_zero_adjust_average(str,num){
    if(str==='vel')document.getElementById(`vel_zero_adjust_value${num}`).value=calc_average(vel_data[num]);
    else if(str==='pos')document.getElementById(`pos_zero_adjust_value${num}`).value=calc_average(pos_data[num]);
    else document.getElementById(`acc_zero_adjust_value${num}`).value=calc_average(acc_data[num]);
  }

  // 加速度のゼロ調整
  function acc_zero_adjust(){
    let i,j,k=0;
    let val=[];
    for(i=0;i<nacc;i++)if(document.getElementById(`acc_zero_adjust_check${i}`).checked==true){
      val[i]=Number(document.getElementById(`acc_zero_adjust_value${i}`).value);
      for(j=1;j<=ntwidth;j++)unif_acc_data[i][j]-=val[i]-zero_adjust_val['acc'][i];
      if(nuacc>nacc)for(j=1;j<=ntwidth;j++)unif_acc_data[i+nacc][j]-=val[i]-zero_adjust_val['acc'][i];
      zero_adjust_val['acc'][i]=val[i];
      k++;
    }
    if(k){
      plot_graph_all('acc',width2,height2);
      document.getElementById('message_acc_zero_adjust').innerHTML='';
    }else document.getElementById('message_acc_zero_adjust').innerHTML='いずれか1つにはチェックを入れてください．';
  }

  // 速度のゼロ調整
  function vel_zero_adjust(){
    let i,j,k=0;
    let val=[];
    for(i=0;i<nacc;i++)if(document.getElementById(`vel_zero_adjust_check${i}`).checked==true){
      val[i]=Number(document.getElementById(`vel_zero_adjust_value${i}`).value);
      for(j=1;j<=ntwidth;j++)unif_vel_data[i][j]-=val[i]-zero_adjust_val['vel'][i];
      if(nuvel>nacc)for(j=1;j<=ntwidth;j++)unif_vel_data[i+nacc][j]-=val[i]-zero_adjust_val['vel'][i];
      zero_adjust_val['vel'][i]=val[i];
      k++;
    }
    if(k){
      plot_graph_all('vel',width2,height2);
      document.getElementById('message_vel_zero_adjust').innerHTML='';
    }else document.getElementById('message_vel_zero_adjust').innerHTML='いずれか1つにはチェックを入れてください．';
  }

  // 位置のゼロ調整
  function pos_zero_adjust(){
    let i,j,k=0;
    let val=[];
    for(i=0;i<nacc;i++)if(document.getElementById(`pos_zero_adjust_check${i}`).checked==true){
      val[i]=Number(document.getElementById(`pos_zero_adjust_value${i}`).value);
      for(j=1;j<=ntwidth;j++)unif_pos_data[i][j]-=val[i]-zero_adjust_val['pos'][i];
      if(nupos>nacc)for(j=1;j<=ntwidth;j++)unif_pos_data[i+nacc][j]-=val[i]-zero_adjust_val['pos'][i];
      zero_adjust_val['pos'][i]=val[i];
      k++;
    }
    if(k){
      plot_graph_all('pos',width2,height2);
      document.getElementById('message_pos_zero_adjust').innerHTML='';
    }else document.getElementById('message_pos_zero_adjust').innerHTML='いずれか1つにはチェックを入れてください．';
  }

  // 加速度のゼロ調整の解除
  function cancel_acc_zero_adjust(){
    let i,j,k=0;

    for(i=0;i<nacc;i++){
      for(j=1;j<=ntwidth;j++)unif_acc_data[i][j]+=zero_adjust_val['acc'][i];
      if(nuacc>nacc)for(j=1;j<=ntwidth;j++)unif_acc_data[i+nacc][j]+=zero_adjust_val['acc'][i];
      document.getElementById(`acc_zero_adjust_check${i}`).checked=false;
      document.getElementById(`acc_zero_adjust_value${i}`).value=0.0;
      zero_adjust_val['acc'][i]=0.0;
      k++;
    }
    if(k){
      plot_graph_all('acc',width2,height2);
      document.getElementById('message_acc_zero_adjust').innerHTML='';
    }
  }

  // 速度のゼロ調整の解除
  function cancel_vel_zero_adjust(){
    let i,j,k=0;

    for(i=0;i<nacc;i++){
      for(j=1;j<=ntwidth;j++)unif_vel_data[i][j]+=zero_adjust_val['vel'][i];
      if(nuvel>nacc)for(j=1;j<=ntwidth;j++)unif_vel_data[i+nacc][j]+=zero_adjust_val['vel'][i];
      document.getElementById(`vel_zero_adjust_check${i}`).checked=false;
      document.getElementById(`vel_zero_adjust_value${i}`).value=0.0;
      zero_adjust_val['vel'][i]=0.0;
      k++;
    }
    if(k){
      plot_graph_all('vel',width2,height2);
      document.getElementById('message_vel_zero_adjust').innerHTML='';
    }
  }

  // 位置のゼロ調整の解除
  function cancel_pos_zero_adjust(){
    let i,j,k=0;

    for(i=0;i<nacc;i++){
      for(j=1;j<=ntwidth;j++)unif_pos_data[i][j]+=zero_adjust_val['pos'][i];
      if(nupos>nacc)for(j=1;j<=ntwidth;j++)unif_pos_data[i+nacc][j]+=zero_adjust_val['pos'][i];
      document.getElementById(`pos_zero_adjust_check${i}`).checked=false;
      document.getElementById(`pos_zero_adjust_value${i}`).value=0.0;
      zero_adjust_val['pos'][i]=0.0;
      k++;
    }
    if(k){
      plot_graph_all('pos',width2,height2);
      document.getElementById('message_pos_zero_adjust').innerHTML='';
    }
  }

  // フーリエ変換の時間分解数の表示
  function show_fft_ndiv(str){
    document.getElementById(`${str}_fft_ndiv_value`).innerHTML=document.getElementById(`${str}_fft_div`).value;
  }

  // 逆フーリエ変換のカットオフ周波数の表示
  function show_ifft_cut_freq(str){
    let val=Number(document.getElementById(`${str}_ifft_cut_freq`).value);
    document.getElementById(`${str}_ifft_cut_freq_value`).innerHTML=val.toFixed(3);
  }

  // 加速度のフーリエ変換
  function acc_fft(){
    let i,ndiv=ntwidth;
    let df=1.0/(time_data[ntwidth]-time_data[1]);
    let dflg=0;
    let amps=[]; // amplitude spectrum

    if(document.getElementById(`check_acc_fft_flag`).checked==true){
      dflg=1;
      ndiv=Number(document.getElementById(`acc_fft_div`).value);
    }

    acc_fft_data=fourier_transformation(time_data,unif_acc_data,nacc,ntwidth,ndiv,dflg);
    let nf=acc_fft_data[0].length;
    let freq=make_frequency(nf,df);
    for(i=0;i<nacc;i++){
      amps[i]=[];
      amps[i][0]=acc_data[i][0];
      for(j=0;j<nf;j++)amps[i][j+1]=math.abs(acc_fft_data[i][j]);
    }
    freq.splice(0,0,'Frequency[Hz]');

    if(!document.getElementById('acc_fft_graph').classList.contains('js-plotly-plot')){
      document.getElementById('acc_fft_graph').style.width=`${width2}px`;
      document.getElementById('acc_fft_graph').style.height=`${height2}px`;
    }
    plot_graph(freq,amps,0,nacc-1,'加速度のフーリエ変換（振幅スペクトル）','強度'+acc_unit,'acc_fft_graph');
    document.getElementById('acc_fft_graph').style.display='block';

    const ifft_cut_freq=document.getElementById('acc_ifft_cut_freq');
    ifft_cut_freq.min=df;
    ifft_cut_freq.max=0.5*nf*df;
    ifft_cut_freq.step=`${df}`;
    ifft_cut_freq.value=nf*df;
    show_ifft_cut_freq('acc');
    ifft_cut_freq.addEventListener('input',function(){show_ifft_cut_freq('acc');});
    document.getElementById('acc_inverse_fourier_transformation').style.display='block';
  }

  // 速度のフーリエ変換
  function vel_fft(){
    let i,ndiv=ntwidth;
    let df=1.0/(time_data[ntwidth]-time_data[1]);
    let dflg=0;
    let amps=[]; // amplitude spectrum

    if(document.getElementById(`check_vel_fft_flag`).checked==true){
      dflg=1;
      ndiv=Number(document.getElementById(`vel_fft_div`).value);
    }

    vel_fft_data=fourier_transformation(time_data,unif_vel_data,nacc,ntwidth,ndiv,dflg);
    let nf=vel_fft_data[0].length;
    let freq=make_frequency(nf,df);
    for(i=0;i<nacc;i++){
      amps[i]=[];
      amps[i][0]=vel_data[i][0];
      for(j=0;j<nf;j++)amps[i][j+1]=math.abs(vel_fft_data[i][j]);
    }
    freq.splice(0,0,'Frequency[Hz]');

    if(!document.getElementById('vel_fft_graph').classList.contains('js-plotly-plot')){
      document.getElementById('vel_fft_graph').style.width=`${width2}px`;
      document.getElementById('vel_fft_graph').style.height=`${height2}px`;
    }
    plot_graph(freq,amps,0,nacc-1,'速度のフーリエ変換（振幅スペクトル）','強度'+vel_unit,'vel_fft_graph');
    document.getElementById('vel_fft_graph').style.display='block';

    const ifft_cut_freq=document.getElementById('vel_ifft_cut_freq');
    ifft_cut_freq.min=df;
    ifft_cut_freq.max=0.5*nf*df;
    ifft_cut_freq.step=`${df}`;
    ifft_cut_freq.value=nf*df;
    show_ifft_cut_freq('vel');
    ifft_cut_freq.addEventListener('input',function(){show_ifft_cut_freq('vel');});
    document.getElementById('vel_inverse_fourier_transformation').style.display='block';
  }

  // 位置のフーリエ変換
  function pos_fft(){
    let i,ndiv=ntwidth;
    let df=1.0/(time_data[ntwidth]-time_data[1]);
    let dflg=0;
    let amps=[]; // amplitude spectrum

    if(document.getElementById(`check_pos_fft_flag`).checked==true){
      dflg=1;
      ndiv=Number(document.getElementById(`pos_fft_div`).value);
    }

    pos_fft_data=fourier_transformation(time_data,unif_pos_data,nacc,ntwidth,ndiv,dflg);
    let nf=pos_fft_data[0].length;
    let freq=make_frequency(nf,df);
    for(i=0;i<nacc;i++){
      amps[i]=[];
      amps[i][0]=pos_data[i][0];
      for(j=0;j<nf;j++)amps[i][j+1]=math.abs(pos_fft_data[i][j]);
    }
    freq.splice(0,0,'Frequency[Hz]');

    if(!document.getElementById('pos_fft_graph').classList.contains('js-plotly-plot')){
      document.getElementById('pos_fft_graph').style.width=`${width2}px`;
      document.getElementById('pos_fft_graph').style.height=`${height2}px`;
    }
    plot_graph(freq,amps,0,nacc-1,'位置のフーリエ変換（振幅スペクトル）','強度'+pos_unit,'pos_fft_graph');
    document.getElementById('pos_fft_graph').style.display='block';

    const ifft_cut_freq=document.getElementById('pos_ifft_cut_freq');
    ifft_cut_freq.min=df;
    ifft_cut_freq.max=0.5*nf*df;
    ifft_cut_freq.step=`${df}`;
    ifft_cut_freq.value=nf*df;
    show_ifft_cut_freq('pos');
    ifft_cut_freq.addEventListener('input',function(){show_ifft_cut_freq('pos');});
    document.getElementById('pos_inverse_fourier_transformation').style.display='block';
  }

  // 逆フーリエ変換による加速度の平滑化
  function acc_ifft_smoothing(){
    let i,j;
    let dflg=0;
    let nf=acc_fft_data[0].length;
    let idx=math.round((time_data[ntwidth]-time_data[1])*Number(document.getElementById('acc_ifft_cut_freq').value))+1;
    let fft_data=[];

    if(document.getElementById(`check_acc_fft_flag`).checked==true)dflg=1;

    for(i=0;i<nacc;i++){
      fft_data[i]=[];
      for(j=0;j<nf;j++){
        fft_data[i][j]=math.complex(0,0);
        fft_data[i][j].re=acc_fft_data[i][j].re;
        fft_data[i][j].im=acc_fft_data[i][j].im;
      }
    }

    if(nuacc>nacc)for(let i=0;i<nacc*2;i++)unif_acc_data.pop();
    nuacc=nacc*3;
    unif_acc_data=inverse_fourier_transformation(time_data,unif_acc_data,fft_data,nacc,nf,idx,'acc');
    document.getElementById('acc_for_integral_items').style.display='block';
    if(document.getElementById('pca_data_radio_select').motion_data.value==='acc')insert_item_select(unif_acc_data,nuacc,'pca_data_select');
    plot_graph_all('acc',width2,height2);
  }

  // 逆フーリエ変換による速度の平滑化
  function vel_ifft_smoothing(){
    let i,j;
    let dflg=0;
    let nf=vel_fft_data[0].length;
    let idx=math.round((time_data[ntwidth]-time_data[1])*Number(document.getElementById('vel_ifft_cut_freq').value))+1;
    let fft_data=[];

    if(document.getElementById(`check_vel_fft_flag`).checked==true)dflg=1;

    for(i=0;i<nacc;i++){
      fft_data[i]=[];
      for(j=0;j<nf;j++){
        fft_data[i][j]=math.complex(0,0);
        fft_data[i][j].re=vel_fft_data[i][j].re;
        fft_data[i][j].im=vel_fft_data[i][j].im;
      }
    }

    if(nuvel>nacc)for(let i=0;i<nacc*2;i++)unif_vel_data.pop();
    nuvel=nacc*3;
    unif_vel_data=inverse_fourier_transformation(time_data,unif_vel_data,fft_data,nacc,nf,idx,'vel');
    document.getElementById('vel_for_integral_items').style.display='block';
    if(document.getElementById('pca_data_radio_select').motion_data.value==='vel')insert_item_select(unif_vel_data,nuvel,'pca_data_select');
    plot_graph_all('vel',width2,height2);
  }

  // 逆フーリエ変換による位置の平滑化
  function pos_ifft_smoothing(){
    let i,j;
    let dflg=0;
    let nf=pos_fft_data[0].length;
    let idx=math.round((time_data[ntwidth]-time_data[1])*Number(document.getElementById('pos_ifft_cut_freq').value))+1;
    let fft_data=[];

    if(document.getElementById(`check_pos_fft_flag`).checked==true)dflg=1;

    for(i=0;i<nacc;i++){
      fft_data[i]=[];
      for(j=0;j<nf;j++){
        fft_data[i][j]=math.complex(0,0);
        fft_data[i][j].re=pos_fft_data[i][j].re;
        fft_data[i][j].im=pos_fft_data[i][j].im;
      }
    }

    if(nupos>nacc)for(let i=0;i<nacc*2;i++)unif_pos_data.pop();
    nupos=nacc*3;
    unif_pos_data=inverse_fourier_transformation(time_data,unif_pos_data,fft_data,nacc,nf,idx,'pos');
    document.getElementById('pos_for_output_items').style.display='block';
    if(document.getElementById('pca_data_radio_select').motion_data.value==='pos')insert_item_select(unif_pos_data,nupos,'pca_data_select');
    plot_graph_all('pos',width2,height2);
  }

  // 最小二乗近似による加速度の平滑化
  function acc_least_square_smoothing(){
    if(nuacc>nacc)for(let i=0;i<nacc*2;i++)unif_acc_data.pop();
    nuacc=nacc*3;
    unif_acc_data=least_square_smoothing(time_data,nacc,unif_acc_data,ntwidth,'acc');
    document.getElementById('acc_for_integral_items').style.display='block';
    if(document.getElementById('pca_data_radio_select').motion_data.value==='acc')insert_item_select(unif_acc_data,nuacc,'pca_data_select');
    plot_graph_all('acc',width2,height2);
  }

  // 最小二乗近似による速度の平滑化
  function vel_least_square_smoothing(){
    if(nuvel>nacc)for(let i=0;i<nacc*2;i++)unif_vel_data.pop();
    nuvel=nacc*3;
    unif_vel_data=least_square_smoothing(time_data,nacc,unif_vel_data,ntwidth,'vel');
    document.getElementById('vel_for_integral_items').style.display='block';
    if(document.getElementById('pca_data_radio_select').motion_data.value==='vel')insert_item_select(unif_vel_data,nuvel,'pca_data_select');
    plot_graph_all('vel',width2,height2);
  }

  // 最小二乗近似による位置の平滑化
  function pos_least_square_smoothing(){
    if(nupos>nacc)for(let i=0;i<nacc*2;i++)unif_pos_data.pop();
    nupos=nacc*3;
    unif_pos_data=least_square_smoothing(time_data,nacc,unif_pos_data,ntwidth,'pos');
    document.getElementById('pos_for_output_items').style.display='block';
    if(document.getElementById('pca_data_radio_select').motion_data.value==='pos')insert_item_select(unif_pos_data,nupos,'pca_data_select');
    plot_graph_all('pos',width2,height2);
  }

  // 加速度の平滑化のクリア
  function clear_acc_smoothing(){
    if(nuacc>nacc){
      nuacc/=3;
      for(let i=0;i<nacc*2;i++)unif_acc_data.pop();
    }
    clear_proc('acc',unif_acc_data,1);
  }

  // 速度の平滑化のクリア
  function clear_vel_smoothing(){
    if(nuvel>nacc){
      nuvel/=3;
      for(let i=0;i<nacc*2;i++)unif_vel_data.pop();
    }
    clear_proc('vel',unif_vel_data,1);
  }

  // 位置の平滑化のクリア
  function clear_pos_smoothing(){
    if(nupos>nacc){
      nupos/=3;
      for(let i=0;i<nacc*2;i++)unif_pos_data.pop();
    }
    clear_proc('pos',unif_pos_data,0);
  }

  // 平滑化のクリア時の共通処理（データ表・グラフ・主成分分析対象データから平滑化データの削除）
  function clear_proc(str,ydata,flg){
    if(flg)document.getElementById(`${str}_for_integral_items`).style.display='none';
    else document.getElementById('pos_for_output_items').style.display='none';
    document.getElementsByName(`${str}_radio`)[0].checked=true;
    if(document.getElementById('pca_data_radio_select').motion_data.value===str)insert_item_select(ydata,nacc,'pca_data_select');
    let insertElement=make_table(time_data,ydata,nacc);
    document.getElementById(`${str}_table`).innerHTML=insertElement;
    plot_graph_all(str,width2,height2);
  }

  // 数値積分による速度の計算
  function calc_velocity(){
    let i,n;

    clear_area(3);

    acc_rv=Number(document.getElementById('acc_for_integral_radio_select').acc_radio.value);
    for(i=0;i<nacc;i++)iacc_index[i]=i+acc_rv*nacc;
    vel_data=numerical_integration(time_data,unif_acc_data,nacc,iacc_index,ntwidth,'vel',vel_unit);
    nuvel=nacc;
    unif_vel_data=copyMatrix(vel_data);

    plot_graph_all('vel',width2,height2); 
    document.getElementById('vel_graph').style.display='block';

    document.getElementsByName('vel_radio')[0].checked=true;
    document.getElementById('vel_for_integral_items').style.display='none';

    let insertElement=`<span style="font-weight:bold;">&#9679; 初期位置（開始時刻 t = ${time_data[1]} s での位置）の設定</span><br />`;
    insertElement+='<div style="margin-left:1em;">';
    for(i=0;i<nacc;i++)insertElement+=`第${i+1}成分：<input type="number" id="inipos${i+1}" value="0.0" step="0.1" /><br />`;
    insertElement+='<button onclick="calc_position();">位置の計算（数値積分）</button>';
    insertElement+='</div>';
    document.getElementById('set_initial_position').innerHTML=insertElement;
    document.getElementById('set_initial_position').style.display='block';
  }

  // 数値積分による位置の計算
  function calc_position(){
    let i;

    clear_area(4);

    vel_rv=Number(document.getElementById('vel_for_integral_radio_select').vel_radio.value);
    for(i=0;i<nacc;i++)ivel_index[i]=i+vel_rv*nacc;
    pos_data=numerical_integration(time_data,unif_vel_data,nacc,ivel_index,ntwidth,'pos',pos_unit);
    nupos=nacc;
    unif_pos_data=copyMatrix(pos_data);

    plot_graph_all('pos',width2,height2); 
    document.getElementById('pos_graph').style.display='block';

    document.getElementsByName('pos_radio')[0].checked=true;
    document.getElementById('pos_for_output_items').style.display='none';
    document.getElementById('acc_vel_pos_output').style.display='block';

    let insertElement='';
    time_data.forEach((element,index) => {
      if(index>0){
        insertElement+=`<option value="${index}">${element}</option>`;
      }
    });
    document.getElementById('trjc_start_time_select').innerHTML=insertElement;
    document.getElementById('trjc_end_time_select').innerHTML=insertElement;
    document.getElementById('trjc_end_time_select').options[ntwidth-2].selected=true;
  }

  // データの算術平均の計算
  function calc_average(data){
    let i,n=data.length;
    let w=0.0;
    for(i=1;i<n;i++)w+=data[i];
    return w/n;
  }

  // データ表の作成
  function make_table(xdata,ydata,ny){
    let i;
    let insertElement='';
    xdata.forEach((element,index) => {
      if(index==0){
        insertElement+=`<tr style="position:sticky;top:0px;"><th>No.</th><th>${element}</th>`;
        for(i=0;i<ny;i++)insertElement+=`<th>${ydata[i][0]}</th>`;
        insertElement+='</tr>';
      }else{
        insertElement+=`<tr><td>${index}</td><td>${element}</td>`;
        for(i=0;i<ny;i++)insertElement+=`<td>${ydata[i][index].toFixed(5)}</td>`;
        insertElement+='</tr>';
      }
    });
    return insertElement;
  }

  // グラフのプロット
  function plot_graph(xdata,ydata,is,ie,title,ylabel,cmps,width,height){
    let trace,layout,resp;
    let plot_data=[];
    if(is<1)is=0;
    for(let i=is;i<=ie;i++){
      trace={
        x: xdata.slice(1),
        y: ydata[i].slice(1),
        mode: plot_mode,
        marker: {size: marker_size},
        line: {width: line_width},
        name: ydata[i][0].replace('^2','<sup>2</sup>')
      };
      plot_data.push(trace);
    }
    if(width===undefined||height===undefined){
      layout={
        title: title,
        xaxis: {title: xdata[0]},
        yaxis: {title: ylabel},
        autosize: true
      };
      resp={responsive: true};
    }else{
      layout={
        title: title,
        xaxis: {title: xdata[0]},
        yaxis: {title: ylabel},
        autosize: false,
        width: width,
        height: height
      };
      resp={responsive: false};
    }
    Plotly.newPlot(cmps,plot_data,layout,resp);
  }

  // 加速度・速度・位置のグラフを纏めてプロット
  function plot_graph_all(str,width,height){
    let i,j,elem;
    const gdata=[];
    if(str==='vel'){
      if(nuvel>nacc){
        for(i=0;i<3;i++)gdata[i]=[];
        for(i=0;i<nacc;i++){
          for(j=0;j<=ntwidth;j++)gdata[0][j]=unif_vel_data[i][j];
          for(j=0;j<=ntwidth;j++)gdata[1][j]=unif_vel_data[i+nacc][j];
          for(j=0;j<=ntwidth;j++)gdata[2][j]=unif_vel_data[i+nacc*2][j];
          elem = document.getElementById(`vel_graph${i}`);
          elem.style.display='block';
          if(!elem.classList.contains('js-plotly-plot')){
            elem.style.width=`${width}px`;
            elem.style.height=`${height}px`;
          }
          plot_graph(time_data,gdata,0,2,`第${i+1}成分の速度(${unif_vel_data[i][0]})<br />平滑化(smth),差分(diff)のグラフ`,`v<sub>${i+1}</sub>`+vel_unit,`vel_graph${i}`);
        }
      }else{
        for(i=0;i<nacc;i++){
          elem = document.getElementById(`vel_graph${i}`);
          elem.style.display='block';
          if(!elem.classList.contains('js-plotly-plot')){
            elem.style.width=`${width}px`;
            elem.style.height=`${height}px`;
          }
          plot_graph(time_data,unif_vel_data,i,i,`第${i+1}成分の速度(${unif_vel_data[i][0]})のグラフ`,`v<sub>${i+1}</sub>`+vel_unit,`vel_graph${i}`);
        }
      }
    }else if(str==='pos'){
      if(nupos>nacc){
        for(i=0;i<3;i++)gdata[i]=[];
        for(i=0;i<nacc;i++){
          for(j=0;j<=ntwidth;j++)gdata[0][j]=unif_pos_data[i][j];
          for(j=0;j<=ntwidth;j++)gdata[1][j]=unif_pos_data[i+nacc][j];
          for(j=0;j<=ntwidth;j++)gdata[2][j]=unif_pos_data[i+nacc*2][j];
          elem = document.getElementById(`pos_graph${i}`);
          elem.style.display='block';
          if(!elem.classList.contains('js-plotly-plot')){
            elem.style.width=`${width}px`;
            elem.style.height=`${height}px`;
          }
          plot_graph(time_data,gdata,0,2,`第${i+1}成分の位置(${unif_pos_data[i][0]})<br />平滑化(smth),差分(diff)のグラフ`,`r<sub>${i+1}</sub>`+pos_unit,`pos_graph${i}`);
        }
      }else{
        for(i=0;i<nacc;i++){
          elem = document.getElementById(`pos_graph${i}`);
          elem.style.display='block';
          if(!elem.classList.contains('js-plotly-plot')){
            elem.style.width=`${width}px`;
            elem.style.height=`${height}px`;
          }
          plot_graph(time_data,unif_pos_data,i,i,`第${i+1}成分の位置(${unif_pos_data[i][0]})のグラフ`,`r<sub>${i+1}</sub>`+pos_unit,`pos_graph${i}`);
        }
      }
    }else{
      if(nuacc>nacc){
        for(i=0;i<3;i++)gdata[i]=[];
        for(i=0;i<nacc;i++){
          for(j=0;j<=ntwidth;j++)gdata[0][j]=unif_acc_data[i][j];
          for(j=0;j<=ntwidth;j++)gdata[1][j]=unif_acc_data[i+nacc][j];
          for(j=0;j<=ntwidth;j++)gdata[2][j]=unif_acc_data[i+nacc*2][j];
          elem = document.getElementById(`acc_graph${i}`);
          elem.style.display='block';
          if(!elem.classList.contains('js-plotly-plot')){
            elem.style.width=`${width}px`;
            elem.style.height=`${height}px`;
          }
          plot_graph(time_data,gdata,0,2,`第${i+1}成分の加速度(${unif_acc_data[i][0].replace('^2','<sup>2</sup>')})<br />平滑化(smth),差分(diff)のグラフ`,`a<sub>${i+1}</sub>`+acc_unit,`acc_graph${i}`);
        }
      }else{
        for(i=0;i<nacc;i++){
          elem = document.getElementById(`acc_graph${i}`);
          elem.style.display='block';
          if(!elem.classList.contains('js-plotly-plot')){
            elem.style.width=`${width}px`;
            elem.style.height=`${height}px`;
          }
          plot_graph(time_data,unif_acc_data,i,i,`第${i+1}成分の加速度(${unif_acc_data[i][0].replace('^2','<sup>2</sup>')})のグラフ`,`a<sub>${i+1}</sub>`+acc_unit,`acc_graph${i}`);
        }
      }
    }
  }

  // 2次元配列のコピー：base のコピーを返す
  function copyMatrix(base){
    const result=[];
    for(const line of base)result.push([...line]);
    return result;
  }

  // 2次元配列の結合：array1 に array2 を結合する
  function pushTwoDimensionalArray(array1,array2,axis){
    let i;
    if(axis!=1)axis=0;
    if(axis==0){  //　縦方向の追加
      for(i=0;i<array2.length;i++){
        array1.push(array2[i]);
      }
    }
    else{  //　横方向の追加
      for(i=0;i<array1.length;i++){
        Array.prototype.push.apply(array1[i],array2[i]);
      }
    }
  }

  // 2次元配列の結合：array1 と array2 を結合した配列を返す
  function concatTwoDimensionalArray(array1,array2,axis){
    let i;
    if(axis!=1)axis=0;
    let array3=[];
    if(axis==0){  //　縦方向の結合
      array3=array1.slice();
      for(i=0;i<array2.length;i++){
        array3.push(array2[i]);
      }
    }
    else{  //　横方向の結合
      for(i=0;i<array1.length;i++){
        array3[i]=array1[i].concat(array2[i]);
      }
    }
    return array3;
  }

  // 最小二乗近似による平滑化処理
  function least_square_smoothing(xdata,ny,ydata,nd,str){
    let i,j,flag=0;
    let fwidth=Number(document.getElementById(`${str}_filter_width_value`).value);
    let norder=Number(document.getElementById(`${str}_polynomial_order`).value);
    let nfilter;
    let xw;
    let iyv=[];
    let diff_data=[];

    if(document.getElementById(`check_${str}_flag`).checked==true)flag=1;

    if(fwidth>0.0)document.getElementById(`${str}_filter_width`).value=fwidth;
    else{
      fwidth=document.getElementById(`${str}_filter_width`).value;
      document.getElementById(`${str}_filter_width_value`).value=fwidth;
    } 

    i=1;
    xw=0.0;
    while(xw<fwidth&&i<nd)xw=xdata[++i]-xdata[1];
    if(i%2)nfilter=i;else nfilter=i-1;

    document.getElementById(`message_${str}_least_square_smoothing`).innerHTML='データ幅：'+nfilter;

    if(norder<0)norder=0;
    for(i=0;i<ny;i++)iyv[i]=i;

    let smth_data=general_least_squares_smoothing(xdata,ydata,1,nd,ny,iyv,nfilter,norder,0,flag,'smth_');

    for(i=0;i<ny;i++){
      diff_data[i]=[];
      diff_data[i][0]='diff_'+ydata[i][0];
      for(j=1;j<=nd;j++)diff_data[i][j]=ydata[i][j]-smth_data[i][j];
    }

    let unif_data=concatTwoDimensionalArray(ydata,smth_data);
    pushTwoDimensionalArray(unif_data,diff_data);

    let insertElement=make_table(xdata,unif_data,ny*3);
    document.getElementById(`${str}_table`).innerHTML=insertElement;

    return unif_data;
  }

  // 選択オプションの挿入
  function insert_item_select(ydata,ny,idstr){
    let i;
    let insertElement='';
    for(i=0;i<ny;i++){
      insertElement+=`<option value="${i}">${ydata[i][0]}</option>`;
    }
    document.getElementById(idstr).innerHTML=insertElement;
  }

  // 平滑化のフィルター幅の変更
  function filter_width_change(str){
    document.getElementById(`${str}_filter_width_value`).value=document.getElementById(`${str}_filter_width`).value;
  }

  // 数値積分
  function numerical_integration(xdata,ypdata,ny,iyv,nd,str,unitstr){
    let i,w;
    let inival=[];

    for(i=0;i<ny;i++){
      inival[i]=Number(document.getElementById(`ini${str}${i+1}`).value);
    }
    let ydata=integration_by_trapezoidal_rule(xdata,ypdata,ny,iyv,nd,inival);
    for(i=0;i<ny;i++)ydata[i][0]=`${str}${i+1}${unitstr}`;

    let insertElement=make_table(xdata,ydata,ny);
    document.getElementById(`${str}_table`).innerHTML=insertElement;
    document.getElementById(`${str}_details`).style.display='block';

    set_fft_zero_adjust(ydata,ny,str);

    const acc_fileter_width=document.getElementById('acc_filter_width');
    const filter_width=document.getElementById(`${str}_filter_width`);
    filter_width.min=acc_filter_width.min;
    filter_width.max=acc_filter_width.max;
    filter_width.step='any';
    filter_width.value=acc_filter_width.value;
    filter_width.addEventListener('input',function(){filter_width_change(str);});
    filter_width_change(str);
    document.getElementById(`${str}_polynomial_order`).value=document.getElementById('acc_polynomial_order').value;
    if(document.getElementById('check_acc_flag').checked==true)document.getElementById(`check_${str}_flag`).checked=true;
    else document.getElementById(`check_${str}_flag`).checked=false;
    document.getElementById(`${str}_smoothing`).style.display='block';

    return ydata;
  }

  // ゼロ調整とフーリエ変換の前処理
  function set_fft_zero_adjust(ydata,ny,str){
    let i;

    insertElement='';
    for(i=0;i<ny;i++){
      //w=calc_average(ydata[i]);
      w=0.0;
      insertElement+=`<label><input type="checkbox" id="${str}_zero_adjust_check${i}" />第${i+1}成分のゼロ調整</label>`;
      insertElement+=`：値&nbsp;<input type="number" id="${str}_zero_adjust_value${i}" value="${w}" step="0.1" />`;
      insertElement+=`&nbsp;&nbsp;<button onclick='calc_zero_adjust_average("${str}",${i})'>平均</button><br />`;
      zero_adjust_val[str][i]=0.0;
    }
    insertElement+=`<button onclick="${str}_zero_adjust();">ゼロ調整</button>&nbsp;&nbsp;`;
    insertElement+=`<button onclick="cancel_${str}_zero_adjust();">解除</button>&nbsp;&nbsp;<span id="message_${str}_zero_adjust"></span>`;
    document.getElementById(`${str}_zero_adjust_area`).innerHTML=insertElement;

    const fft_div=document.getElementById(`${str}_fft_div`);
    if(ntwidth<20)fft_div.min=ntwidth;else fft_div.min=20;
    fft_div.max=ntwidth*2;
    fft_div.step='1';
    fft_div.value=ntwidth;
    fft_div.addEventListener('input',function(){show_fft_ndiv(str);});
    document.getElementById(`${str}_fft_ndiv_value`).innerHTML=fft_div.value;

  }

  // 台形公式による積分
  function integration_by_trapezoidal_rule(xv,yv,ny,idx,n,iniv){
    let i,j;
    let niv=[];

    for(j=0;j<ny;j++){
      niv[j]=[];
      niv[j][0]=`item${j+1}`;
      niv[j][1]=iniv[j];
    }
    for(i=2;i<=n;i++)for(j=0;j<ny;j++)niv[j][i]=niv[j][i-1]+0.5*(yv[idx[j]][i]+yv[idx[j]][i-1])*(xv[i]-xv[i-1]);

    return niv;
  }

  // フーリエ変換
  function fourier_transformation(xdata,ydata,ny,nd,ndiv,dflg){
    let i,j,k,nx;
    let xw;
    let dx=xdata[2]-xdata[1];
    let yp=[],ffty=[];

    for(j=0;j<ny;j++){
      yp[j]=[];
      yp[j][0]=ydata[j][1];
    }

    if(dflg){
      if(ndiv>20){
        dx=(xdata[nd]-xdata[1])/ndiv;
      }else{
        for(i=3;i<=nd;i++){
          xw=xdata[i]-xdata[i-1];
          if(xw<dx)dx=xw;
        }
      }
      nx=math.floor((xdata[nd]-xdata[1])/dx)+1;
      nk=1;
      k=1;
      xw=xdata[1];
      while(xdata[++k]<xw+0.5*dx&&k<=nd){
        nk++;
        for(j=0;j<ny;j++)yp[j][0]+=ydata[j][k];
      }
      for(j=0;j<ny;j++)yp[j][0]/=nk;
      for(i=1;i<nx;i++){
        xw+=dx;
        nk=0;
        for(j=0;j<ny;j++)yp[j][i]=0.0;
        while(xdata[k]<xw+0.5*dx){
          if(k==nd)break;
          for(j=0;j<ny;j++)yp[j][i]+=ydata[j][k];
          k++;
          nk++;
        }
        if(nk>1)for(j=0;j<ny;j++)yp[j][i]/=nk;
        else for(j=0;j<ny;j++)yp[j][i]=dx*(ydata[j][k]-yp[j][i-1])/(xdata[k]-xw+dx)+yp[j][i-1];
        if(k==nd)break;
      }
    }else{
      for(j=0;j<ny;j++)for(i=2;i<=nd;i++)yp[j][i-1]=ydata[j][i];
    }

    for(j=0;j<ny;j++)ffty[j]=math.fft(yp[j]);
    return ffty;
  }

  // フーリエ変換したデータに対する横軸（周波数）の設定
  function make_frequency(n,df){
    let i;
    let x=[];
    if(n%2==0){
      for(i=0;i<n/2;i++)x[i]=i*df;
      for(i=n/2;i<n;i++)x[i]=(i-n)*df;
    }else{
      for(i=0;i<(n+1)/2;i++)x[i]=i*df;
      for(i=(n+1)/2;i<n;i++)x[i]=(i-n)*df;
    }
    return x;
  }

  // 逆フーリエ変換
  function inverse_fourier_transformation(xdata,ydata,fft_data,ny,nf,idx,str){
    let i,j,k;
    let nd=xdata.length-1;
    let dn=2*((nf+nf%2)/2-idx);
    let dx=(xdata[nd]-xdata[1])/(nf-1);
    let ifft_data=[];
    let re=[],diff_data=[];;

    for(i=0;i<ny;i++){
      j=idx;
      k=dn;
      while(k>0){
        fft_data[i][j].re=fft_data[i][j].im=0.0;
        j++;
        k--;
      }
      ifft_data[i]=math.ifft(fft_data[i]);
      re[i]=[];
      re[i][0]='smth_'+ydata[i][0];
      re[i][1]=ifft_data[i][0].re;
      k=2;
      for(j=1;j<nf;j++){
        x=xdata[1]+j*dx;
        while(x>xdata[k]&&k<=nd){
          re[i][k]=ifft_data[i][j-1].re+(ifft_data[i][j].re-ifft_data[i][j-1].re)*(dx-x+xdata[k])/dx;
          k++;
        }
      }
      for(j=k;j<=nd;j++)re[i][j]=ydata[i][j];
    }

    for(i=0;i<ny;i++){
      diff_data[i]=[];
      diff_data[i][0]='diff_'+ydata[i][0];
      for(j=1;j<=nd;j++)diff_data[i][j]=ydata[i][j]-re[i][j];
    }

    let unif_data=concatTwoDimensionalArray(ydata,re);
    pushTwoDimensionalArray(unif_data,diff_data);

    let insertElement=make_table(xdata,unif_data,ny*3);
    document.getElementById(`${str}_table`).innerHTML=insertElement;

    return unif_data;
  }

  // 加速度・速度・位置データの統合
  function merge_acc_vel_pos_data(){
    let i,j,nt=nacc*3;

    pos_rv=Number(document.getElementById('pos_for_output_radio_select').pos_radio.value);

    for(i=0;i<nt;i++)acc_vel_pos_data[i]=[];
    for(i=0;i<nacc;i++){
      for(j=0;j<=ntwidth;j++){
        acc_vel_pos_data[i][j]=unif_acc_data[i+acc_rv*nacc][j];
        acc_vel_pos_data[i+nacc][j]=unif_vel_data[i+vel_rv*nacc][j];
        acc_vel_pos_data[i+nacc*2][j]=unif_pos_data[i+pos_rv*nacc][j];
      }
    }

    document.getElementById('acc_vel_pos_area').style.height='300px';
    let insertElement=make_table(time_data,acc_vel_pos_data,nt);
    document.getElementById('acc_vel_pos_table').innerHTML=insertElement;

    if(!document.getElementById('tacc_graph').classList.contains('js-plotly-plot')){
      document.getElementById('tacc_graph').style.width=`${width2}px`;
      document.getElementById('tacc_graph').style.height=`${height2}px`;
    }
    plot_graph(time_data,acc_vel_pos_data,0,nacc-1,'加速度のグラフ','a'+acc_unit,'tacc_graph');
    if(!document.getElementById('tvel_graph').classList.contains('js-plotly-plot')){
      document.getElementById('tvel_graph').style.width=`${width2}px`;
      document.getElementById('tvel_graph').style.height=`${height2}px`;
    }
    plot_graph(time_data,acc_vel_pos_data,nacc,2*nacc-1,'速度のグラフ','v'+vel_unit,'tvel_graph');
    if(!document.getElementById('tpos_graph').classList.contains('js-plotly-plot')){
      document.getElementById('tpos_graph').style.width=`${width2}px`;
      document.getElementById('tpos_graph').style.height=`${height2}px`;
    }
    plot_graph(time_data,acc_vel_pos_data,2*nacc,3*nacc-1,'位置のグラフ','r'+pos_unit,'tpos_graph');
    document.getElementById('acc_vel_pos_graph').style.display='block';

    insertElement='&nbsp;&nbsp;<button onclick="download_acc_vel_pos_data();">ダウンロード</button>';
    insertElement+='&nbsp;&nbsp;<span style="color:red;font-size:smaller">※ CSVファイルとしてダウンロードします．</span>';
    document.getElementById('data_download').innerHTML=insertElement;
    document.getElementById('acc_vel_pos_area').style.display='block';
    if(nacc>1)document.getElementById('trajectory').style.display='block';
  }

  // 軌跡のプロット
  function plot_trajectory(){
    let i;
    let layout,resp,width=width1;
    trjc_start_time_index=Number(document.getElementById('trjc_start_time_select').value);
    const trjc_end_time_index=Number(document.getElementById('trjc_end_time_select').value);
    const ntw=trjc_end_time_index-trjc_start_time_index+1;
    const ts=time_data[trjc_start_time_index];
    const te=time_data[trjc_end_time_index];
    let mp=[],hwd=0.0,vrt,w1,w2;

    if(aid)cancelAnimationFrame(aid);
    
    step=0;
    dstep=1;
    stopflag=0;

    if(!nupos){
      document.getElementById('message_trjc_time_range').innerHTML='位置データがありません！';
      return;
    }

    if(te-ts<0){
      document.getElementById('message_trjc_time_range').innerHTML='終了時刻は開始時刻より後に設定してください！';
      return;
    }
    document.getElementById('message_trjc_time_range').innerHTML='';

    dtt=(te-ts)/(trjc_end_time_index-trjc_start_time_index);
    vrt=dtt*vec_len;
    for(i=0;i<nacc;i++){
      trjc_acc[i]=acc_vel_pos_data[i].slice(trjc_start_time_index,trjc_end_time_index+1);
      trjc_vel[i]=acc_vel_pos_data[i+nacc].slice(trjc_start_time_index,trjc_end_time_index+1);
      trjc_data[i]=acc_vel_pos_data[i+nacc*2].slice(trjc_start_time_index,trjc_end_time_index+1);
    }

    let insertElement='&nbsp;&nbsp;<input type="button" value="スタート" onclick="motion_start(this)" />';
    insertElement+='&nbsp;&nbsp;&nbsp;&nbsp;遅&nbsp;<input type="range" value="1" min="1" max="10" onchange="chage_step_width(this)" />&nbsp;速';
    if(dev_type==="phone")insertElement+="<br />";
    insertElement+=`&nbsp;&nbsp;&nbsp;&nbsp;time = <span id="trajectory_time">${ts.toFixed(3)}</span> s<br />`;
    insertElement+='&nbsp;&nbsp;<label><input type="checkbox" id="check_vel_vec" checked onchange="change_vel_vec_check(this)" /><span style="color:blue;">速度ベクトル</span></label>';
    insertElement+='&nbsp;&nbsp;<label><input type="checkbox" id="check_acc_vec" checked onchange="change_acc_vec_check(this)" /><span style="color:green;">加速度ベクトル</span></label>';
    insertElement+='&nbsp;&nbsp;&nbsp;&nbsp;短&nbsp;<input type="range" value="10" min="1" max="20" onchange="change_vector_length(this)" />&nbsp;長';
    document.getElementById('message_trajectory').innerHTML=insertElement;
    if(nacc==2){
      if(!trjc_elem.classList.contains('js-plotly-plot')){
        trjc_elem.style.width=`${width}px`;
        trjc_elem.style.height=`${width}px`;
      }
      for(i=0;i<2;i++){
        w1=math.max(trjc_data[i]);
        w2=math.min(trjc_data[i]);
        mp[i]=0.5*(w1+w2);
        w1=0.5*(w1-w2);
        if(hwd<w1)hwd=w1;
      }
      hwd*=1.05;
      tpdata={type: 'scatter', mode: 'lines', x: trjc_data[0], y: trjc_data[1], line: {width: line_width, color: 'red'}};
      pdata={
        type: 'scatter', mode: 'markers',
        x: [trjc_data[0][0]], y: [trjc_data[1][0]],
        marker: {size: marker_size+3, color: 'black'}
      };
      vel_arw={
        x: trjc_data[0][0]+trjc_vel[0][0]*vrt,
        y: trjc_data[1][0]+trjc_vel[1][0]*vrt,
        xref: 'x',
        yref: 'y',
        ax: trjc_data[0][0],
        ay: trjc_data[1][0],
        axref: 'x',
        ayref: 'y',
        text: '',
        showarrow: true,
        arrowcolor: 'blue',
        arrowhead: 2,
        arrowsize: 1,
        arrowwidth: 2
      };
      acc_arw={
        x: trjc_data[0][0]+trjc_acc[0][0]*vrt*vrt,
        y: trjc_data[1][0]+trjc_acc[1][0]*vrt*vrt,
        xref: 'x',
        yref: 'y',
        ax: trjc_data[0][0],
        ay: trjc_data[1][0],
        axref: 'x',
        ayref: 'y',
        text: '',
        showarrow: true,
        arrowcolor: 'green',
        arrowhead: 2,
        arrowsize: 1,
        arrowwidth: 2
      }
      layout={
        title: '軌跡',
        xaxis: {range: [mp[0]-hwd,mp[0]+hwd], title: acc_vel_pos_data[nacc*2][0]},
        yaxis: {range: [mp[1]-hwd,mp[1]+hwd], title: acc_vel_pos_data[nacc*2+1][0]},
        showlegend: false,
        autosize: true,
        annotations: [vel_arw,acc_arw]
      };
      Plotly.newPlot(trjc_elem,[tpdata,pdata],layout);
      trjc_elem.style.display='block';
    }else if(nacc==3){
      if(dev_type!=='phone')width+=200;
      if(!trjc_elem.classList.contains('js-plotly-plot')){
        trjc_elem.style.width=`${width}px`;
        trjc_elem.style.height=`${width}px`;
      }
      for(i=0;i<3;i++){
        w1=math.max(trjc_data[i]);
        w2=math.min(trjc_data[i]);
        mp[i]=0.5*(w1+w2);
        w1=0.5*(w1-w2);
        if(hwd<w1)hwd=w1;
      }
      hwd*=1.05;
      tpdata={
        type: 'scatter3d',
        mode: 'lines',
        x: trjc_data[0],
        y: trjc_data[1],
        z: trjc_data[2],
        opacity: 1,
        line: {
          width: line_width+1,
          color: 'red'
        }
      };
      layout = {
        title: '軌跡',
        scene: {
          aspectmode: 'cube',
          xaxis: {range: [mp[0]-hwd,mp[0]+hwd], title: acc_vel_pos_data[nacc*2][0]},
          yaxis: {range: [mp[1]-hwd,mp[1]+hwd], title: acc_vel_pos_data[nacc*2+1][0]},
          zaxis: {range: [mp[2]-hwd,mp[2]+hwd], title: acc_vel_pos_data[nacc*2+2][0]}
        },
        showlegend: false,
        autosize: true
      };
      pdata={
        type: 'scatter3d', mode: 'markers',
        x: [trjc_data[0][0]], y: [trjc_data[1][0]], z: [trjc_data[2][0]],
        marker: {size: marker_size, color: 'black'}
      };
      vel_arw={
        type: 'scatter3d', mode: 'lines',
        x: [trjc_data[0][0], trjc_data[0][0]+trjc_vel[0][0]*vrt],
        y: [trjc_data[1][0], trjc_data[1][0]+trjc_vel[1][0]*vrt],
        z: [trjc_data[2][0], trjc_data[2][0]+trjc_vel[2][0]*vrt],
        line: {width: 5, color: 'blue'},
        visible: true
      };
      acc_arw={
        type: 'scatter3d', mode: 'lines',
        x: [trjc_data[0][0], trjc_data[0][0]+trjc_acc[0][0]*vrt*vrt],
        y: [trjc_data[1][0], trjc_data[1][0]+trjc_acc[1][0]*vrt*vrt],
        z: [trjc_data[2][0], trjc_data[2][0]+trjc_acc[2][0]*vrt*vrt],
        line: {width: 5, color: 'green'},
        visible: true
      };
      w1=math.norm([trjc_vel[0][0],trjc_vel[1][0],trjc_vel[2][0]]);
      if(w1==0)w1=1;
      vel_cone={
        type: 'cone',
        x: [trjc_data[0][0]+trjc_vel[0][0]*vrt],
        y: [trjc_data[1][0]+trjc_vel[1][0]*vrt],
        z: [trjc_data[2][0]+trjc_vel[2][0]*vrt],
        u: [trjc_vel[0][0]/w1],
        v: [trjc_vel[1][0]/w1],
        w: [trjc_vel[2][0]/w1],
        sizemode: 'absolute',
        sizeref: conescale*hwd,
        showscale: false,
        colorscale: [[0, 'blue'], [1, 'blue']],
        visible: true
      };
      w1=math.norm([trjc_acc[0][0],trjc_acc[1][0],trjc_acc[2][0]]);
      if(w1==0)w1=1;
      acc_cone={
        type: 'cone',
        x: [trjc_data[0][0]+trjc_acc[0][0]*vrt*vrt],
        y: [trjc_data[1][0]+trjc_acc[1][0]*vrt*vrt],
        z: [trjc_data[2][0]+trjc_acc[2][0]*vrt*vrt],
        u: [trjc_acc[0][0]/w1],
        v: [trjc_acc[1][0]/w1],
        w: [trjc_acc[2][0]/w1],
        sizemode: 'absolute',
        sizeref: conescale*hwd,
        showscale: false,
        colorscale: [[0, 'green'], [1, 'green']],
        visible: true
      };
      Plotly.newPlot(trjc_elem,[tpdata,pdata,vel_arw,vel_cone,acc_arw,acc_cone],layout);
      trjc_elem.style.display='block';
    }else document.getElementById('message_trajectory').innerHTML='1次元データでは軌跡をプロットできません．'
  }

  // 軌跡のアニメーション処理
  function trajectory_animation(){
    let vrt=dtt*vec_len,w;
    step+=dstep;
    if(step>=trjc_data[0].length)step-=trjc_data[0].length;
    if(nacc==2){
      // 点の座標の更新
      pdata.x=[trjc_data[0][step]];
      pdata.y=[trjc_data[1][step]];
      Plotly.deleteTraces(trjc_elem,1);
      Plotly.addTraces(trjc_elem,pdata);
      // 速度ベクトルの更新
      vel_arw.x=trjc_data[0][step]+trjc_vel[0][step]*vrt;
      vel_arw.y=trjc_data[1][step]+trjc_vel[1][step]*vrt;
      vel_arw.ax=trjc_data[0][step];
      vel_arw.ay=trjc_data[1][step];
      // 加速度ベクトルの更新
      acc_arw.x=trjc_data[0][step]+trjc_acc[0][step]*vrt*vrt;
      acc_arw.y=trjc_data[1][step]+trjc_acc[1][step]*vrt*vrt;
      acc_arw.ax=trjc_data[0][step];
      acc_arw.ay=trjc_data[1][step];
      Plotly.relayout(trjc_elem,{annotations: [vel_arw,acc_arw]});
    }else{
      // 点の座標の更新
      pdata.x=[trjc_data[0][step]];
      pdata.y=[trjc_data[1][step]];
      pdata.z=[trjc_data[2][step]];
      // 速度ベクトルの更新
      vel_arw.x=[trjc_data[0][step],trjc_data[0][step]+trjc_vel[0][step]*vrt];
      vel_arw.y=[trjc_data[1][step],trjc_data[1][step]+trjc_vel[1][step]*vrt];
      vel_arw.z=[trjc_data[2][step],trjc_data[2][step]+trjc_vel[2][step]*vrt];
      // 速度ベクトルの矢印の更新
      vel_cone.x=[trjc_data[0][step]+trjc_vel[0][step]*vrt];
      vel_cone.y=[trjc_data[1][step]+trjc_vel[1][step]*vrt];
      vel_cone.z=[trjc_data[2][step]+trjc_vel[2][step]*vrt];
      w=math.norm([trjc_vel[0][step],trjc_vel[1][step],trjc_vel[2][step]]);
      if(w==0)w=1;
      vel_cone.u=[trjc_vel[0][step]/w];
      vel_cone.v=[trjc_vel[1][step]/w];
      vel_cone.w=[trjc_vel[2][step]/w];
      // 加速度ベクトルの更新
      acc_arw.x=[trjc_data[0][step],trjc_data[0][step]+trjc_acc[0][step]*vrt*vrt];
      acc_arw.y=[trjc_data[1][step],trjc_data[1][step]+trjc_acc[1][step]*vrt*vrt];
      acc_arw.z=[trjc_data[2][step],trjc_data[2][step]+trjc_acc[2][step]*vrt*vrt];
      // 加速度ベクトルの矢印の更新
      acc_cone.x=[trjc_data[0][step]+trjc_acc[0][step]*vrt*vrt];
      acc_cone.y=[trjc_data[1][step]+trjc_acc[1][step]*vrt*vrt];
      acc_cone.z=[trjc_data[2][step]+trjc_acc[2][step]*vrt*vrt];
      w=math.norm([trjc_acc[0][step],trjc_acc[1][step],trjc_acc[2][step]]);
      if(w==0)w=1;
      acc_cone.u=[trjc_acc[0][step]/w];
      acc_cone.v=[trjc_acc[1][step]/w];
      acc_cone.w=[trjc_acc[2][step]/w];
      // プロットの更新
      Plotly.deleteTraces(trjc_elem,[1,2,3,4,5]);
      Plotly.addTraces(trjc_elem,[pdata,vel_arw,vel_cone,acc_arw,acc_cone]);
    }
    document.getElementById('trajectory_time').innerHTML=time_data[step+trjc_start_time_index].toFixed(3);

    aid=requestAnimationFrame(trajectory_animation);
  }

  // アニメーションのスタート・ストップ処理
  function motion_start(button){
    stopflag=1-stopflag;
    if(stopflag){
      button.value='ストップ';
      trajectory_animation();
    }else{
      button.value='スタート';
      cancelAnimationFrame(aid);
    }
  }

  // アニメーションのステップ幅の変更
  function chage_step_width(slider){
    dstep=Number(slider.value);
  }

  // 速度ベクトルの表示・非表示切り替え
  function change_vel_vec_check(checkbox){
    if(nacc==2){
      vel_arw.showarrow=checkbox.checked;
      Plotly.relayout(trjc_elem,{annotations: [vel_arw,acc_arw]});
    }else{
      let update={
        visible: checkbox.checked
      }
      Plotly.restyle(trjc_elem,update,[2,3]);
      vel_arw.visible=checkbox.checked;
      vel_cone.visible=checkbox.checked;
    }
  }

  // 加速度ベクトルの表示・非表示切り替え
  function change_acc_vec_check(checkbox){
    if(nacc==2){
      acc_arw.showarrow=checkbox.checked;
      Plotly.relayout(trjc_elem,{annotations: [vel_arw,acc_arw]});
    }else{
      let update={
        visible: checkbox.checked
      }
      Plotly.restyle(trjc_elem,update,[4,5]);
      acc_arw.visible=checkbox.checked;
      acc_cone.visible=checkbox.checked;
    }
  }

  // 速度・加速度ベクトルの長さの変更
  function change_vector_length(slider){
    let vrt;
    vec_len=Number(slider.value);
    vrt=dtt*vec_len;
    if(nacc==2){
      vel_arw.x=trjc_data[0][step]+trjc_vel[0][step]*vrt;
      vel_arw.y=trjc_data[1][step]+trjc_vel[1][step]*vrt;
      acc_arw.x=trjc_data[0][step]+trjc_acc[0][step]*vrt*vrt;
      acc_arw.y=trjc_data[1][step]+trjc_acc[1][step]*vrt*vrt;
      Plotly.relayout(trjc_elem,{annotations: [vel_arw,acc_arw]});
    }else{
      // 速度ベクトルの更新
      vel_arw.x=[trjc_data[0][step],trjc_data[0][step]+trjc_vel[0][step]*vrt];
      vel_arw.y=[trjc_data[1][step],trjc_data[1][step]+trjc_vel[1][step]*vrt];
      vel_arw.z=[trjc_data[2][step],trjc_data[2][step]+trjc_vel[2][step]*vrt];
      // 速度ベクトルの矢印の更新
      vel_cone.x=[trjc_data[0][step]+trjc_vel[0][step]*vrt];
      vel_cone.y=[trjc_data[1][step]+trjc_vel[1][step]*vrt];
      vel_cone.z=[trjc_data[2][step]+trjc_vel[2][step]*vrt];
      // 加速度ベクトルの更新
      acc_arw.x=[trjc_data[0][step],trjc_data[0][step]+trjc_acc[0][step]*vrt*vrt];
      acc_arw.y=[trjc_data[1][step],trjc_data[1][step]+trjc_acc[1][step]*vrt*vrt];
      acc_arw.z=[trjc_data[2][step],trjc_data[2][step]+trjc_acc[2][step]*vrt*vrt];
      // 加速度ベクトルの矢印の更新
      acc_cone.x=[trjc_data[0][step]+trjc_acc[0][step]*vrt*vrt];
      acc_cone.y=[trjc_data[1][step]+trjc_acc[1][step]*vrt*vrt];
      acc_cone.z=[trjc_data[2][step]+trjc_acc[2][step]*vrt*vrt];
      // プロットの更新
      Plotly.deleteTraces(trjc_elem,[2,3,4,5]);
      Plotly.addTraces(trjc_elem,[vel_arw,vel_cone,acc_arw,acc_cone]);
    }
  }

  // 主成分分析における対象データの変更処理
  function pca_check_button_change(str){
    let i;
    let insertElement='';

    if(str==='vel'){
      if(nuvel)for(i=0;i<nuvel;i++)insertElement+=`<option value="${i}">${unif_vel_data[i][0]}</option>`;
      else insertElement='<option value="">--No data--</option>'
    }else if(str==='pos'){
      if(nupos)for(i=0;i<nupos;i++)insertElement+=`<option value="${i}">${unif_pos_data[i][0]}</option>`;
      else insertElement='<option value="">--No data--</option>'
    }else{
      for(i=0;i<nuacc;i++)insertElement+=`<option value="${i}">${unif_acc_data[i][0]}</option>`;
    }
    document.getElementById('pca_data_select').innerHTML=insertElement;
  }

  // 主成分分析の計算
  function calc_pca(){
    let i,j,k;
    let pca_data=[];
    let graph_data;
    let str,w;

    const pca_mdtype=document.getElementById('pca_data_radio_select').motion_data.value;

    pca_index.length=0;
    npca=0;
    for(let option of document.getElementById('pca_data_select').options){
      if(option.selected){
        pca_index.push(option.value);
        npca++;
      }
    }
    if(npca<2||npca>3){
      document.getElementById('message_pca_data_select').innerHTML='いずれか2つ以上3つ以下で選択してください！';
      return;
    }
    document.getElementById('message_pca_data_select').innerHTML='';
  
    const start_time_index=Number(document.getElementById('pca_start_time_select').value);
    const end_time_index=Number(document.getElementById('pca_end_time_select').value);
    const npcatw=end_time_index-start_time_index+1;
    const ts=time_data[start_time_index];
    const te=time_data[end_time_index];
    if(te-ts<0){
      document.getElementById('message_pca_time_range').innerHTML='終了時刻は開始時刻より後に設定してください！';
      return;
    }
    document.getElementById('message_pca_time_range').innerHTML='';

    if(pca_mdtype==='vel'){
      for(i=0;i<npcatw;i++){
        pca_data[i]=[];
        for(j=0;j<npca;j++)pca_data[i][j]=unif_vel_data[pca_index[j]][i+start_time_index];
      }
    }else if(pca_mdtype==='pos'){
      for(i=0;i<npcatw;i++){
        pca_data[i]=[];
        for(j=0;j<npca;j++)pca_data[i][j]=unif_pos_data[pca_index[j]][i+start_time_index];
      }
    }else{
      for(i=0;i<npcatw;i++){
        pca_data[i]=[];
        for(j=0;j<npca;j++)pca_data[i][j]=unif_acc_data[pca_index[j]][i+start_time_index];
      }
    }

    pcares=PCA.getEigenVectors(pca_data);

    let insertElement='';
    for(i=0;i<npca;i++){
      insertElement+=`<span style="font-weight:bold;">第${i+1}主成分</span>：固有値 ${pcares[i].eigenvalue.toFixed(5)}<br />&nbsp;&nbsp;&nbsp;&nbsp;主成分負荷量&nbsp;&nbsp;`;
      for(j=0;j<npca;j++)insertElement+=`<input type="number" id="coef${i+1}_${j+1}" value="${pcares[i].vector[j]}" />&nbsp;`;
      insertElement+='<br />';
    }
    document.getElementById('pca_coeff').innerHTML=insertElement;

    if(pca_mdtype==='vel'){
      graph_data=convert_axis(npca,pca_index,pcares,ntwidth,unif_vel_data);
      str='速度'+vel_unit;
    }else if(pca_mdtype==='pos'){
      graph_data=convert_axis(npca,pca_index,pcares,ntwidth,unif_pos_data);
      str='位置'+pos_unit;
    }else{
      graph_data=convert_axis(npca,pca_index,pcares,ntwidth,unif_acc_data);
      str='加速度'+acc_unit;
    }
    graph_data[0][0]='first principal component';
    graph_data[1][0]='second principal component';
    if(npca>2)graph_data[2][0]='third principal component';

    if(!document.getElementById('pca_graph').classList.contains('js-plotly-plot')){
      document.getElementById('pca_graph').style.width=`${width1}px`;
      document.getElementById('pca_graph').style.height=`${height1}px`;
    }
    plot_graph(time_data,graph_data,0,npca-1,'座標軸変換したグラフ',str,'pca_graph');
    document.getElementById('pca_result').style.display='block';
  }

  // 各座標軸の変換
  function convert_axis(npca,index,pcares,nd,ydata){
    let i,j,k,w;
    let cdata=[];
    for(i=0;i<npca;i++)cdata[i]=[];
    for(i=0;i<npca;i++)for(j=1;j<=nd;j++){
      w=0.0;
      for(k=0;k<npca;k++)w+=pcares[i].vector[k]*ydata[index[k]][j];
      cdata[i][j]=w;
    }
    return cdata;
  }

  // すべての座標軸の変換処理
  function all_axis_conversion(){
    let i,j,k,n,nt=nacc;
    let index=[];
    let tmp;
    let cnv=[];

    for(i=0;i<npca;i++)cnv[i]={eigenvalue: pcares[i].eigenvalue,vector:[]};
    for(i=0;i<npca;i++)for(j=0;j<npca;j++)cnv[i].vector.push(Number(document.getElementById(`coef${i+1}_${j+1}`).value));

    acc_vel_pos_data.length=0;
    for(i=0;i<nacc;i++)acc_vel_pos_data[i]=[];
    for(i=0;i<npca;i++)index[i]=pca_index[i]%nacc;

    // convert acceleration axes
    if(acc_rv===undefined)acc_rv=Number(document.getElementById('acc_for_integral_radio_select').acc_radio.value);
    n=acc_rv*nacc;
    for(i=0;i<npca;i++)index[i]=pca_index[i]%nacc+n;
    tmp=convert_axis(npca,index,cnv,ntwidth,unif_acc_data);
    for(i=0,k=0;i<nacc;i++){
      if(index[k]==i+n){
        for(j=1;j<=ntwidth;j++)acc_vel_pos_data[i][j]=tmp[k][j];
        acc_vel_pos_data[i][0]=`acc_pca${k+1}`
        k++;
      }else for(j=0;j<=ntwidth;j++)acc_vel_pos_data[i][j]=unif_acc_data[i+n][j];
    }

    // convert velocity axes
    if(nuvel){
      nt+=nacc;
      for(i=nacc;i<nacc*2;i++)acc_vel_pos_data[i]=[];
      if(vel_rv===undefined)vel_rv=Number(document.getElementById('vel_for_integral_radio_select').vel_radio.value);
      n=vel_rv*nacc;
      for(i=0;i<npca;i++)index[i]=pca_index[i]%nacc+n;
      tmp=convert_axis(npca,index,cnv,ntwidth,unif_vel_data);
      for(i=0,k=0;i<nacc;i++){
        if(index[k]==i+n){
          for(j=1;j<=ntwidth;j++)acc_vel_pos_data[i+nacc][j]=tmp[k][j];
          acc_vel_pos_data[i+nacc][0]=`vel_pca${k+1}`
          k++;
        }else for(j=0;j<=ntwidth;j++)acc_vel_pos_data[i+nacc][j]=unif_vel_data[i+n][j];
      }
    }
    if(nupos){
      nt+=nacc;
      for(i=nacc*2;i<nacc*3;i++)acc_vel_pos_data[i]=[];
      if(pos_rv===undefined)pos_rv=Number(document.getElementById('pos_for_output_radio_select').pos_radio.value);
      n=pos_rv*nacc;
      for(i=0;i<npca;i++)index[i]=pca_index[i]%nacc+n;
      tmp=convert_axis(npca,index,cnv,ntwidth,unif_pos_data);
      for(i=0,k=0;i<nacc;i++){
        if(index[k]==i+n){
          for(j=1;j<=ntwidth;j++)acc_vel_pos_data[i+nacc*2][j]=tmp[k][j];
          acc_vel_pos_data[i+nacc*2][0]=`pos_pca${k+1}`
          k++;
        }else for(j=0;j<=ntwidth;j++)acc_vel_pos_data[i+nacc*2][j]=unif_pos_data[i+n][j];
      }
    }

    document.getElementById('acc_vel_pos_area').style.height='300px';
    let insertElement=make_table(time_data,acc_vel_pos_data,nt);
    document.getElementById('acc_vel_pos_table').innerHTML=insertElement;

    plot_graph(time_data,acc_vel_pos_data,0,nacc-1,'座標変換した加速度のグラフ','a'+acc_unit,'tacc_graph');
    if(nuvel)plot_graph(time_data,acc_vel_pos_data,nacc,2*nacc-1,'座標変換した速度のグラフ','v'+vel_unit,'tvel_graph');
    if(nupos)plot_graph(time_data,acc_vel_pos_data,2*nacc,3*nacc-1,'座標変換した位置のグラフ','r'+pos_unit,'tpos_graph');

    insertElement='&nbsp;&nbsp;<button onclick="download_acc_vel_pos_data();">ダウンロード</button>';
    insertElement+='&nbsp;&nbsp;<span style="color:red;font-size:smaller">※ CSVファイルとしてダウンロードします．</span>';
    document.getElementById('data_download').innerHTML=insertElement;

    document.getElementById('acc_vel_pos_output').style.display='block';

    if(document.getElementById('trajectory_plot').style.display==='block'){
      document.getElementById('trajectory_plot').style.display='none';
      if(stopflag)cancelAnimationFrame(aid);
      Plotly.purge('trajectory_plot');
      document.getElementById('message_trajectory').innerHTML='';
    }
  }

  // 表示領域のクリア
  function clear_area(level){
    if(level<1)document.getElementById('time_range').style.display='none';
    if(level<2){
      document.getElementById('acc_details').style.display='none';
      document.getElementById('acc_graph').style.display='none';
      for(i=0;i<nacc;i++){
        Plotly.purge(`acc_graph${i}`);
        document.getElementById(`acc_graph${i}`).classList.remove('js-plotly-plot');
        document.getElementById(`acc_graph${i}`).style.display='none';
      }
      document.getElementById('acc_smoothing').style.display='none';
      document.getElementById('acc_zero_adjust').open=false;
      document.getElementById('acc_fourier_transformation').open=false;
      if(acc_fft_data.length!=0){
        Plotly.purge('acc_fft_graph');
        document.getElementById('acc_fft_graph').classList.remove('js-plotly-plot');
        document.getElementById('acc_fft_graph').style.display='none';
      }
      document.getElementById('acc_inverse_fourier_transformation').style.display='none';
      document.getElementById('acc_least_square_smoothing').open=false;
      document.getElementById('acc_for_integral_items').style.display='none';
      document.getElementById('set_initial_velocity').style.display='none';
      document.getElementById('axis_conversion_with_pca').style.display='none';
      document.getElementById('axis_conversion_with_pca').open=false;
    }
    if(level<3){
      document.getElementById('vel_details').style.display='none';
      document.getElementById('vel_graph').style.display='none';
      for(i=0;i<nacc;i++){
        Plotly.purge(`vel_graph${i}`);
        document.getElementById(`vel_graph${i}`).classList.remove('js-plotly-plot');
        document.getElementById(`vel_graph${i}`).style.display='none';
      }
      document.getElementById('vel_smoothing').style.display='none';
      document.getElementById('vel_zero_adjust').open=false;
      document.getElementById('vel_fourier_transformation').open=false;
      if(vel_fft_data.length!=0){
        Plotly.purge('vel_fft_graph');
        document.getElementById('vel_fft_graph').classList.remove('js-plotly-plot');
        document.getElementById('vel_fft_graph').style.display='none';
      }
      document.getElementById('vel_inverse_fourier_transformation').style.display='none';
      document.getElementById('vel_least_square_smoothing').open=false;
      document.getElementById('vel_for_integral_items').style.display='none';
      document.getElementById('set_initial_position').style.display='none';
    }
    if(level<4){
      document.getElementById('pos_details').style.display='none';
      document.getElementById('pos_graph').style.display='none';
      for(i=0;i<nacc;i++){
        Plotly.purge(`pos_graph${i}`);
        document.getElementById(`pos_graph${i}`).classList.remove('js-plotly-plot');
        document.getElementById(`pos_graph${i}`).style.display='none';
      }
      document.getElementById('pos_smoothing').style.display='none';
      document.getElementById('pos_zero_adjust').open=false;
      document.getElementById('pos_fourier_transformation').open=false;
      if(vel_fft_data.length!=0){
        Plotly.purge('pos_fft_graph');
        document.getElementById('pos_fft_graph').classList.remove('js-plotly-plot');
        document.getElementById('pos_fft_graph').style.display='none';
      }
      document.getElementById('pos_inverse_fourier_transformation').style.display='none';
      document.getElementById('pos_least_square_smoothing').open=false;
      document.getElementById('pos_for_output_items').style.display='none';
    }
    if(level<5){
      document.getElementById('acc_vel_pos_output').style.display='none';
      document.getElementById('data_download').innerHTML='';
      document.getElementById('acc_vel_pos_area').style.display='none';
      if(document.getElementById('acc_vel_pos_graph').style.display==='block'){
        document.getElementById('acc_vel_pos_graph').style.display='none';
        Plotly.purge('tacc_graph');
        Plotly.purge('tvel_graph');
        Plotly.purge('tpos_graph');
      }
      document.getElementById('trajectory').style.display='none';
      if(document.getElementById('trajectory_plot').style.display==='block'){
        document.getElementById('trajectory_plot').style.display='none';
        if(stopflag)cancelAnimationFrame(aid);
        Plotly.purge('trajectory_plot');
        document.getElementById('message_trajectory').innerHTML='';
      }
    }
  }

  // 元データのダウンロード処理
  function download_sensor_data(){
      exportcsv('sensor',0,data_str);
  }

  // 加速度データのダウンロード処理
  function download_acc_data(){
      exportcsv('acc_data',1,time_data,unif_acc_data,);
  }

  // 速度データのダウンロード処理
  function download_vel_data(){
      exportcsv('vel_data',1,time_data,unif_vel_data);
  }

  // 位置データのダウンロード処理
  function download_pos_data(){
      exportcsv('pos_data',1,time_data,unif_pos_data);
  }

  // データのエクスポート
  function exportcsv(basename,flg,xdata,ydata){
    let i,j;
    let data_str;
    const mimeType='text/csv';
    const date=new Date();
    const year=date.getFullYear();
    const month=('0'+(date.getMonth()+1)).slice(-2);
    const day=('0'+date.getDate()).slice(-2);
    const hour=('0'+date.getHours()).slice(-2);
    const min=('0'+date.getMinutes()).slice(-2);
    const second=('0'+date.getSeconds()).slice(-2);
    const filename=basename+year+month+day+hour+min+second+'.csv';

    if(flg){
      data_str=xdata[0];
      for(j=0;j<ydata.length;j++)data_str+=','+ydata[j][0];
      data_str+='\n';
      for(i=1;i<xdata.length;i++){
        data_str+=xdata[i].toFixed(5);
        for(j=0;j<ydata.length;j++)data_str+=','+ydata[j][i].toFixed(5);
        data_str+='\n';
      }
    }else{
      data_str=xdata;
    }

    const bom=new Uint8Array([0xEF,0xBB,0xBF]);
    const blob=new Blob([bom,data_str],{type:mimeType});

    let element=document.createElement('a');
    element.href=URL.createObjectURL(blob);
    element.download=filename;
    element.click();
    URL.revokeObjectURL(element.href);
  }
</script>

</body>
</html>